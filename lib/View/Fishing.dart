//素材元
//YouTuberのための素材屋さん
//https://ytsozaiyasan.com/
//魔王魂
//https://maou.audio/
//効果音ラボ
//https://soundeffect-lab.info/
//フリーイラスト素材集ジャパクリップ
//https://japaclip.com/terms-ja/

//☆基本概要

//☆残り必要な素材
//・絵
//  船
//  タイラバ
//  ジグ
//  スロージグ
//  背景・１面の山と砂浜
//  背景・１面の高島
//  背景・２面の都会
//  背景・堤防
//  底の岩 ３パターンぐらい
//  底のわかめ
//  底の沈船
//  雲 ３パターンぐらい
//  タイトル画面
//・音
//・音楽
//

//☆残タス
//済・ソナー光点をアニメーション光るにする
//済・HIT率でソナー光点の色を変える or 光る頻度を変える
//済・背景（メインのところ）をソナーにする。
//済・ソナーを画像じゃなく描画にする。
//済・テンションバーを指数的にする。
//済・糸巻中はスピードバーの色変える
//済・深さの変化に傾向をつける
//済・テンションによってテンションバーの色可変
//済・深さ表示をやっぱり上にする
//済・棚の可変化
//済・海上の範囲を描画
//済・海面の波
//済・船押して船長呼び出しの機能 深いとこ／浅いとこ行って欲しい機能
//済・船長呼び出しボタン→子メニュー（ポップアップ？横メニュー？）で選択→船長絵「わかった」
//済・水深によってバックの色の濃さ変える
//済・海底を描画（波と同じようなロジックでいける？）
//済・魚種毎にいい棚の設定
//済・魚種毎にいい速度の設定
//済・ソナーの0m地点に水面とか船の画像。
//済・スライダー関係を全部canvasにする
//済・テンションバーのデザインが変
//済・テンションバー 危ないときアニメーション光るようにする
//済・テンションとスピードバーのデザインを整備 スライダーじゃなくする？
//済・ソナーに反応光点描画にする。
//済・テンション連動点滅がおかしい
//済・魚種毎に大きさ範囲
//済・ドラグが出てる時はどっか揺らすみたいな
//済・ヘッダを大改修
//済・画面左に竿リール表示
//済・竿リール表示を左右切り替えるやつを反対側に
//済・ロッドの曲がりを表現
//済・アワセシステム
//済・魚種毎にバレ条件の設定
//済・アワセの上手くいきかたで初期バラシレベルが決まるみたいな
//済・バレシステムを何とかする
//済・波の下の罫線が気になる、波をBOTTOMで描画すれば解決かも？→しない
//済・HIT時にHIT宣言とアワセ評価を画面中央に出す目立つ
//済・魚図鑑画面
//済・%を表示してる方がおもしろい・・・
//済・ルアー変更
//済・意図のスライダーをテンションとひっつける
//済・糸のHPシステム？糸切れ値でぷっつり行くのが何か変
//済・魚詳細画面
//済・魚種毎に巻き志向←→リアクション志向
//済・魚種毎に底生志向
//済・上下ドラッグで動かす、ジグのシャクリ
//済・大きさでHP可変
//済・タックル変更モーダルに閉じるボタン
//済・自分で船動かす 0m時に左右矢印表示
//済・船動くときに魚反応動かして動いてるのわかるようにする
//済・ワンタッチで回収ボタン
//済・船動かすときにポイント使うようにする
//済・超過画面出すときに画面全体光らす
//済・ゲームオーバー無しにする
//済・ルアー耐久システム
//済・店の基本
//済・スライダーの右下に数値も出す
//済・沖合何メートルの表示
//済・最大水深によって釣れる魚の大きさを制限
//済・ルアー大きさによって釣れる魚の大きさを制限
//済・当たった時にアワセ判定ラインを表示
//済・バレるラインを表示
//済・リールタップしていいとき光らすとかの表示
//済・ルアーめげるシステムいらんくね？
//済・おさかな図鑑画面で？でも何mでつれるかの表示出す
//済・陸から何メートルで釣れる魚変わるシステム
//済・今釣れる可能性のある魚をリスト表示
//済・BGMなんかばぐがある、重い、さいせいすればするほど重くなる？
//済・効果音なんかばぐがある、重い、さいせいすればするほど重くなる？最初にプリロードした方が良いかも
//済・pagesで音がでんくなった（asset小文字大文字変えたせい）
//済・設定画面 音ボリューム
//済・設定画面 合わせの強さ調節
//済・ジャーク感度の調整機能
//済・合わせシステムマシニする
//済・竿のMAXテンションによってジャーク強さかえる
//済・竿のMAXテンションによってバレ判定の速度かえる
//済・魚種を３種類に分けるやつ
//済・つれたときドラグを割合で合わせる
//済・ルアーにレベル
//済・ルアーレベルアップで重さを解禁
//済・画面上に小マップ 沖合XXｍはいらない
//済・初ゲットはポイント2倍
//済・簡易的なタイトル画面
//済・ジャークだけじゃなくフォール、巻も表示j
//・水深20mごとに？おや、風向きが・・・（釣れる魚種の傾向を選択）
//・ジャーク、巻、フォールの確率上昇を積み重ね式にする
//・アタリ時HIT時レア度や初によって音を返る
//・吊り上げ時レア度によって音をかえる
//・店をもっとましにする
//・タックル変更をもっとましにする、特に重さ
//・ドラグ使いにくいの何とかする
//・風の描画？？？いる？
//・雲の描画
//・海底に漁礁とか
//・実績
//・時合度が低いのが続かんようにするか、高くできるようにする
//・王冠つきじゃないと詳細アンロックしない？
//・中断セーブ機能

//・ジャークをリズムで
//・光点が横に走る
//・水中に泡とか
//・全体的見た目何とかする、水中にテカリ的なグラデーションとか
//・時合度を何らか表示（今は魚反応の多さで判断できるが・・・
//・HIT中のアバレベルを何らか表示
//・エリア選択 エリアによって魚種、深さ等変える
//・チュートリアルか、ヘルプか
//・クリア後、最初から振り返りリザルト表示　ここで切られたとかバレた魚種分かる（魚種以外分かるの方がええかも）
//・寝る機能 寝中は何もできずすごい速さでゲームが進む
//・今日はもう納得した機能 ゲームを途中で諦める

//バグ
//・バレた時アワセ失敗したとき光点の色が戻らん
//・サカナ反応が空に浮くのをなおす 全体的に↑にいってるので下にする
//・大量に経験値で一気にレベル上がった時、途中の重さが解放されない
//・Android たまに「System UI isnt responding」「Wrote stack traces to tombstoned」がでる
//　多分FIshPointer関係のバグっぽい？

//リリース前作業
//・全体的に重いのをなんとかする、画像圧縮とか余計な処理消しとか
//・魚種データ登録
//・面データ登録
//・アイコン作り
//・タイトル画面（いらんのでは？）
//・メインメニュー
//・バランス調整

//ボツ
//・水流
//・赤ポイント緑ポイント青ポイント
//・糸切れ判定 勢い度を加味して切れるようにする
//・ポイントで色々　道具買ったり、糸替え、船長指示、ゲームオーバーから復活とか

//夢
//・魚種データをDB化して好きに登録画面実装？
//・アワセシステム ARVRモード時はスマホをジャイロで動かす、通常時は下にドラッグでアワセ
//・背景にAR的なカメラ映像（カメラ無いときはアニメーション）
//・背景にrod、ジャイロで動かす
//・ルアーの成長を曲線的にする

import 'package:fish_flutter/Main.dart';
import 'package:fish_flutter/Model/ImageModel.dart';
import 'package:fish_flutter/Model/LuresModel.dart';
import 'package:fish_flutter/Model/FishModel.dart';
import 'package:fish_flutter/Model/FishResultsModel.dart';
//import 'package:fish_flutter/Model/HaveTackleModel.dart';
import 'package:fish_flutter/Model/SpeedRange.dart';
import 'package:fish_flutter/Model/StageModel.dart';
import 'package:fish_flutter/widget/BookDialog.dart';
import 'package:fish_flutter/widget/FIshCard.dart';
import 'package:fish_flutter/widget/FishRangeSliderPainter.dart';
import 'package:fish_flutter/widget/LightSpot.dart';
import 'package:fish_flutter/widget/RadarChart.dart';
import 'package:fish_flutter/widget/ShopDialog.dart';
import 'package:fish_flutter/widget/SettingDialog.dart';
import 'package:fish_flutter/widget/SoundManagerPool.dart';
import 'package:fish_flutter/widget/TapPointer.dart';
import 'package:fish_flutter/widget/FishPointer.dart';
import 'package:fish_flutter/widget/WaveClipper.dart';
import 'package:fish_flutter/widget/SliderPainter.dart';
import 'package:fish_flutter/widget/fishGetDialog.dart';
import 'package:fish_flutter/widget/imagePainter.dart';
import 'package:fish_flutter/widget/tacklePainter.dart';

import 'package:flutter/material.dart';

import 'dart:async';
import 'dart:math' as math;
import 'dart:ui' as ui;
import 'package:flutter/services.dart' show rootBundle;
import 'dart:typed_data';

import 'package:flutter/rendering.dart';

import 'package:audioplayers/audioplayers.dart';
import 'package:fish_flutter/Class/BasePageState.dart';
import 'package:fish_flutter/Class/clsColor.dart';

import '../widget/ImageList.dart';
import '../widget/goalDialog.dart';

class Fishing extends StatefulWidget {
  Fishing({Key? key}) : super(key: key);
  static String screenBgm = 'bgm_field.mp3';

  @override
  _FishingState createState() => _FishingState();
}

enum PlayerState { stopped, playing, paused }

// つりページのステータス管理
class _FishingState extends BasePageState<Fishing>
    with TickerProviderStateMixin {
  _FishingState()
      : super(fileName: Fishing.screenBgm); // <-- 親クラスのコンストラクタにファイル名設定

  //定数の定義？？？いろいろ環境設定にした方がいいかと
  //モーダル中のBGM

  //late AudioCache _subBgm;
  //late AudioPlayer _ap;

  //デバッグフラグ すぐつれちゃう
  //static const DEBUGFLG = true;
  static const DEBUGFLG = false;

  //魚種定義
  late FishsModel FISH_TABLE;
  //ルアーリスト定義
  late LuresModel lures;
  //現在使用中のルアー
  late LureModel uselureData;
  //所持定義
  //late HaveTackleModel haveTackle;
  //画像リスト
  List<ImageItem> lstImage = [];

  //光点の点滅速度 ？？？テンション最大値によって可変にする
  static const Map<int, int> POINT_DURATION_MSEC = {
    0: 50,
    1: 100,
    2: 300,
    3: 700,
    4: 1000,
    5: 2000,
  };

  //最大水深(0.1m)ごとの風の強さ
  static const Map<int, double> WIND_FOR_DEPTH = {
    // 0: 0.5,
    // 200: 0.6, //0～20mまでは微風で進む
    // 500: 0.5, //20～50mまでは無風
    // 1000: 0.4,
    // 2000: 0.3,
    9999: 0.7,
  };

  static const TIMER_INTERVAL = 50; //1スキャン時間(msec) 20FPS
  //static const TIMER_INTERVAL = 33; //1スキャン時間(msec) 30FPS
  //static const TIMER_INTERVAL = 17; //1スキャン時間(msec) 60FPS
  //static const TENSION_VAL_MAX = 300.0; //テンションスライダーMAX値
  static const TENSION_VAL_MIN = 0.0; //テンションスライダーMIN値
  //static const TENSION_LINECUT = 290.0; //糸切れ判定値
  //static const _speedValMax = 300.0; //巻き速度スライダーMAX値
  static const SPEED_VAL_MIN = 0.0; //巻き速度スライダーMIN値
  static const HOSEI_MAX = 3;
  static const MAX_RAND_ADD_TENSION = 2; //何もしてない時テンションがウロウロするののMAX値
  static const MIN_RAND_ADD_TENSION = -11; //〃 MIN値
  final TENSION_COLOR_SAFE = clsColor.getColorFromHex("007FFF");
  //final TENSION_COLOR_DRAG = clsColor.getColorFromHex("FFD800");
  final TENSION_COLOR_DANGER = clsColor.getColorFromHex("FFFF00");
  final LINE_HP_COLOR = clsColor.getColorFromHex("65B558");
  final SPEED_COLOR = clsColor.getColorFromHex("FFBABE");
  final SPEED_COLOR_REELING = clsColor.getColorFromHex("FF6B77");
  static const DEPTH_CHANGE_SCAN = 500; //このスキャン毎に深さの変化傾向が変わる
  static const JIAI_CHANGE_SCAN = 1500; //このスキャン毎に時合度が変わる
  static const TANA_CHANGE_SCAN = 3000; //このスキャン毎にタナが変わる
  static const POINTER_SIZE = 5.0; //ソナー光点の基本サイズ
  static const POINTER_BACK_SIZE = 4.0; //ソナー光点後光の最大サイズ
  static const ROD_STANDUP_MAX = 100.0; //竿立て度MAX
  static const JERK_SCAN = 10; //ジャークの継続スキャン数
  // static const BAIT_CNT_MAX = 30; //アタリ判定期間
  // static const FOOKING_TENSION = 150; //アワセ成功閾値
  static const MOVE_FISHPOINTER_MAX = 20.0; //最高速度 +-0.5の時の魚反応光点移動量

  static const SHIP_MOVE_POINT = 1; //船移動時の1スキャンポイント消費
  //static const Map<int, double> DEPTH_CHANGE_ORDERS = {0: 0.5, 1: 0.45, 2: 0.55};
  static const Map<int, double> DEPTH_CHANGE_ORDERS = {0: 0.5, 1: 0.2, 2: 0.8};

  // グローバル変数としてGlobalKey型の変数（プロパティ）を定義
  GlobalKey globalKeySonar = GlobalKey();
  GlobalKey globalKeyShore = GlobalKey();
  GlobalKey globalKeyBottom = GlobalKey();
  GlobalKey grobalKeyMinimap = GlobalKey();

  //アニメーション関連
  late AnimationController _animationController; //光点の光アニメーション
  late Animation<double> _animationRadius;
  late AnimationController _centerTextAnimationController; //画面中央に出すテキストアニメーション
  late Animation<double> _centerTextLeft;
  late AnimationController _commonAnimationController; //共通アニメーション
  late Animation<double> _commonAnime;
  late AnimationController _jerkTextAnimationController; //ジャーク時のテキストアニメーション
  late Animation<double> _jerkTextLocation;
  late AnimationController _clutchAnimationController; //クラッチの表示アニメーション
  late Animation<double> _clutchAnime;

  //定周期タイマ
  late Timer _timer;

  //状態フラグ変数
  bool _onTap = false; //現在タップ中フラグ
  bool _onClutch = false; //現在クラッチ状態
  bool _flgBait = false; //現在アタリ中フラグ
  bool _flgHit = false; //現在HIT中フラグ
  bool _flgFooking = false; //アワセモード中フラグ
  //var _flgGameOver = false; //現在ゲームオーバーフラグ

  //ステート変数
  double _tension = 0.0; //テンション値
  double _tensionValMax = 0.0; //テンション最大値 竿によって可変
  double _fookingTension = 0.0; //アタリ時のアワセ判定値
  double _fookingTensionPrev = 0.0; //アワセモード時のテンション前回値記憶
  var _useLureId = enumLureDiv.tairaba; //使用中のルアー種類
  double _drag = 0.0; //ドラグレベル値
  double _speed = 0.0; //巻き速度値
  double _speedValMax = 0.0; //スピード最大値 リールによって可変
  double _depth = 0.0; //現在糸出し量(0.1m)
  double _prevDepth = 0.0; //前回スキャンの糸出し量（浮上判定用）
  double _maxDepth = 50.0; //現在の最大水深(0.1m)
  double _maximumDepth = 1000.0;  //ステージ内の最大水深
  String _dispDepth = '0.0 m'; //深さ表示用
  Color _tensionActiveTrackColor =
      clsColor.getColorFromHex("4CFF00"); //テンションゲージの色
  bool _flgShaKe = false; //ドラグスライダーを揺らす用
  Color _speedActiveTrackColor = clsColor.getColorFromHex("0094FF"); //スピードゲージの色
  Color _infoBackColor = Colors.white; //HIT率表示の背景色（デバッグ用）
  Color _clutchBackColor = Colors.red; //クラッチボタンの背景色
  Color _pointerColor = Colors.yellow; //ソナー部光点の色
  double _lightSpotY = 0.0; //ソナー部光点TOP
  double _lightSpotX = 50.0; //ソナー部光点LEFT
  int _point = 1000; //獲得ポイント
  double _justTana = 0.5; //HIT確率判定 時合棚 0.0～1.0
  double _justTanaRange = 50.0; //0.1m単位 +-までは時合圏内
  int _tanaChangeScanCnt = 0; //棚変化スキャンカウント数
  double _jiai = 0.9; //時合度 0.0～0.9999...
  int _jiaiChangeScanCnt = 0; //時合度の変化スキャンカウント数
  double _maxLineHp = 1000.0; //ラインHP最大値
  double _nowLineHp = 1000.0; //現在ラインHP

  int _shipMoveSeScan = 0;

  double _cursorX = 0.0; //ドラッグ操作開始時の座標X
  double _cursorY = 0.0; //ドラッグ操作開始時の座標Y
  int _jerkCnt = 0; //ジャークの継続スキャン数
  int _baitCnt = 0; //当たってからのスキャン数
  //var _baitMaxTension = 0.0; //バイト中の最大テンション
  double _fookingLv = 0.0; //フッキングの成功度

  late FishModel _hitFish; //現在HIT中の魚種
  double _fishSize = 0.0; //現在HIT中の魚の大きさ MAXを1.0とした時の割合
  int _hitScanCnt = 0; //HITしてからのスキャン数
  int _bareCnt = 0; //バレ判定カウント
  int _abareLv = 0;

  double _shipMove = 0.5; //船の動き 1.0～0,0 +なら深くなる、-なら浅くなる
  double _depthChange = 0.5; //深さの変化傾向 1.0～0,0 +なら深くなる、-なら浅くなる
  //var _depthChangeScanCnt = 0; //深さの変化傾向スキャンカウント数
  //var _depthChangeOrder = 0; //変化傾向 初期値は現状維持
  double _dispDepthLv1 = 0.45; //深さ画面色変える 中層 0m：1.0 70m：0.8
  double _dispDepthLv2 = 0.9; //深さ画面色変える 深層 0m：1.0 100m：0.9

  double _windLevel = 0.5; //風レベル 0.0～1.0 0.5で無風

  var _nowDurationLv; //光点点滅レベル
  double _sonarTop = 0.0;
  double _shoreHeight = 0.0;
  double _bottomHeight = 0.0;
  double _sonarHeight = 0.0;
  double _minimapWidth = 0.0;

  String _centerTextMain = "";
  Color _centerTextMainColor = Colors.red;
  String _centerTextSub = "";
  Color _centerTextSubColor = Colors.black;

  late Offset offset = Offset(0.0, 0.0);
  double _appBarHeight = 0.0;

  late AnimationController waveController; // AnimationControllerの宣言

  bool _ligntSpotAnimationChangeing = false;

  String _actionText = "";

  late StageModel stage;

  //タックルの描画関連
  double _tackleCenterX = 0.0;
  double _rodSizeX = 0.0;
  double _rodSizeY = 0.0;
  double _reelSizeX = 0.0;
  double _reelSizeY = 0.0;
  double _reelCenterY = 0.0;
  var _takcleChangeButtonPosition = MainAxisAlignment.end;
  double _rodStandUp = 0.0;
  double _handleRoll = 0.0;

  //タックル変更モーダル表示非表示
  bool _showTacleChangeDialog = false;
  //タックル変更モーダル内で選択している種類
  var _selectTacleIcon = '';

  //釣果リスト
  late FishesResultModel fishesResult;

  //今の場所で釣れる可能性のある魚種リスト
  List<FishModel> _fishCardItem = [];

  //ドラグ音の再生IDX記憶（連続防止）
  int dragSeIdx = 0;
  //ジャーク音の再生IDX記憶（連続防止）
  int jerkSeIdx = 0;
  //現在再生中のBGMファイル名
  String nowBgm = "";

  //船移動
  // var _MoveLeft = false;
  // var _MoveRight = false;
  //船加速度の目標値
  var _moveShipTarget = 0.5;

  var _collect = false; //高速回収中フラグ

  //沖合何km
  var offShore = 0.0;

  var flgDispSettingsOk = false;

  @override
  void initState() {
    //魚テーブルを初期化？？？本当はエリアで絞る
    FISH_TABLE = new FishsModel();
    //釣果リストを初期化
    fishesResult = new FishesResultModel();
    //今釣れている魚を初期化
    _hitFish = FISH_TABLE.getFishDetail(0);
    //ルアーリストを初期化？？？本当はDBマスタから全取得
    lures = new LuresModel();
    //現在使用中のルアーデータ
    uselureData = lures.getLureData(_useLureId);
    //基本BGM
    nowBgm = Fishing.screenBgm;
    //所持リストを初期化
    //haveTackle = new HaveTackleModel();
    // _tensionValMax = haveTackle.getUseRod().maxTention;
    // _speedValMax = haveTackle.getUseReel().maxSpeed;
    _tensionValMax = 2000.0;
    _speedValMax = 200.0;
    _drag = 0.8;

    // buildメソッドが回り、AppBarの描画終了後に、GlobalKeyの情報を取得するようにするため、
    // addPostFrameCallbackメソッドを実行
    // null safety対応で?（null以外の時のみアクセス）をつける
    WidgetsBinding.instance?.addPostFrameCallback((cb) {

      // `ModalRoute.of()`メソッドを使用して引数を取得
      stage = ModalRoute.of(context)?.settings.arguments as StageModel;

      //スタート深さを設定
      _maxDepth = stage.startDepth;
      //ゴール深さを設定
      _maximumDepth = stage.maximumDepth;
      //風レベル
      _windLevel = stage.windLevel;

      //AppBarの高さを取得
      _appBarHeight = AppBar().preferredSize.height;

      //定周期タイマの開始
      startTimer();
    });

    //光点アニメーションの初期化
    _nowDurationLv = POINT_DURATION_MSEC.length - 1; //初期値は最大値
    ligntSpotAnimation(true, POINT_DURATION_MSEC[_nowDurationLv]!);

    waveController = AnimationController(
      duration: const Duration(seconds: 3), // アニメーションの間隔を3秒に設定
      vsync: this, // おきまり
    )..repeat(); // リピート設定

    _centerTextAnimationController = AnimationController(
        duration: Duration(milliseconds: 2000), vsync: this);

    _jerkTextAnimationController =
        AnimationController(duration: Duration(milliseconds: 800), vsync: this);

    _commonAnimationController = AnimationController(
        duration: Duration(milliseconds: 1500), vsync: this);
    //アニメーションの定義
    _commonAnimationController = AnimationController(
        duration: Duration(milliseconds: 1500), vsync: this);
    _commonAnime = Tween(begin: 0.0, end: 1.0)
        .animate(_commonAnimationController)
        .drive(CurveTween(curve: Curves.easeInOut))
      ..addListener(() {
        setState(() {});
      });
    _commonAnimationController.repeat(reverse: true);

    //クラッチのアニメーション
    _clutchAnimationController = AnimationController(
        duration: Duration(milliseconds: 1500), vsync: this);
    _clutchAnimationController =
        AnimationController(duration: Duration(milliseconds: 200), vsync: this);
    _clutchAnime = Tween(begin: 0.0, end: 1.0)
        .animate(_clutchAnimationController)
        .drive(CurveTween(curve: Curves.easeInOut))
      ..addListener(() {
        setState(() {});
      });
    _clutchAnimationController.repeat(reverse: true);

    super.initState();
  }

  //画像のプリロード？？？ほんとはMAINでやっといたほうがいいかも
  void dispSettings() async {
    //ソナー部のY位置と高さを取得
    var sonarWidget =
        globalKeySonar.currentContext?.findRenderObject() as RenderBox;
    _sonarHeight = sonarWidget.size.height;
    _sonarTop = sonarWidget.localToGlobal(Offset.zero).dy;

    //海上部の高さ
    var shoreWidget =
        globalKeyShore.currentContext?.findRenderObject() as RenderBox;
    _shoreHeight = shoreWidget.size.height;

    //海底部の高さ
    var bottomWidget =
        globalKeyBottom.currentContext?.findRenderObject() as RenderBox;
    _bottomHeight = bottomWidget.size.height;

    //表示画像の定義
    lstImage.add(new ImageItem(
      key: UniqueKey(),
      painterKey: GlobalKey(),
      id: 2,
      imageName: 'sun.png',
      type: enumImageDispType.sky,
      top: _appBarHeight,
      left: MediaQuery.of(context).size.width,
      startDepth: 0.0, //0.1m単位
      endDepth: _maximumDepth, //0.1m単位
      size: MediaQuery.of(context).size,
    ));
    lstImage.add(new ImageItem(
      key: UniqueKey(),
      painterKey: GlobalKey(),
      id: 0,
      imageName: 'mounten.png',
      type: enumImageDispType.surface,
      top: _shoreHeight - 35,
      left: MediaQuery.of(context).size.width,
      //nowMaxDepth: 0.0,
      startDepth: -100.0, //0.1m単位
      endDepth: 250.0, //0.1m単位
      size: MediaQuery.of(context).size,
    ));

    lstImage.add(new ImageItem(
      key: UniqueKey(),
      painterKey: GlobalKey(),
      id: 1,
      imageName: 'teibou.png',
      type: enumImageDispType.surface,
      top: _shoreHeight + 10,
      left: MediaQuery.of(context).size.width,
      startDepth: 0.0, //0.1m単位
      endDepth: 90.0, //0.1m単位
      size: MediaQuery.of(context).size,
    ));
    lstImage.add(new ImageItem(
      key: UniqueKey(),
      painterKey: GlobalKey(),
      id: 3,
      imageName: 'takashima.png',
      type: enumImageDispType.surface,
      top: _shoreHeight - 5,
      left: MediaQuery.of(context).size.width,
      //nowMaxDepth: 0.0,
      startDepth: 700.0, //0.1m単位
      endDepth: 1000.0, //0.1m単位
      size: MediaQuery.of(context).size,
    ));

    flgDispSettingsOk = true;
  }

  void dispose() {
    _timer.cancel();
    _animationController.dispose();
    waveController.dispose(); // AnimationControllerは明示的にdisposeする。
    _centerTextAnimationController.dispose();
    _commonAnimationController.dispose();
    _clutchAnimationController.dispose();
    _jerkTextAnimationController.dispose();
    fishPointerList.clear();
    super.dispose();
  }

  //画面の基本BGM関連
  Future bgmPlay(file) async {
    super.bgm.playBgm(name: file);
  }

  Future bgmPause() async {
    super.bgm.pauseBgmAny();
  }

  Future bgmResume() async {
    super.bgm.resumeBgm();
  }

  Future bgmStop() async {
    super.bgm.stopBgmAny();
  }

  //定周期タイマの起動
  void startTimer() {
    _timer = Timer.periodic(
      Duration(milliseconds: TIMER_INTERVAL),
      onTimer,
    );
  }

  //定周期処理
  void onTimer(Timer timer) async {
    if (!mounted) {
      //既に画面が無効の場合は無処理
      return;
    }

    // _tensionValMax = haveTackle.getUseRod().maxTention;
    // _speedValMax = haveTackle.getUseReel().maxSpeed;
    //画面サイズ取得用
    final Size size = MediaQuery.of(context).size;

    var minimapWidget =
        grobalKeyMinimap.currentContext?.findRenderObject() as RenderBox;
    _minimapWidth = minimapWidget.size.width;

    if (!flgDispSettingsOk) dispSettings();

    //共通乱数 0.0～0.999... の乱数の作成 ※共通じゃだめなところには使っちゃだめ
    var rand = (new math.Random()).nextDouble();

    //風レベル判定
    // for (int key in WIND_FOR_DEPTH.keys) {
    //   if (_maxDepth.toInt() < key) {
    //     _windLevel = WIND_FOR_DEPTH[key] as double;
    //     break;
    //   }
    // }

    //ゴール深さに到達
    bool flgGoal = false;
    if (_maxDepth >= _maximumDepth) {
      flgGoal = true;
      if (!_flgHit && !_flgBait) {
        //ゴール条件成立
        _timer.cancel(); //定周期タイマ停止
        bgmStop();
        var result = await showDialog<int>(
          context: context,
          barrierDismissible: false,
          builder: (_) {
            return Stack(
              children: [
                //ゴールダイアログ
                goalDialog(
                  dispSize: size,
                ),
              ],
            );
          },
        );
        //モーダル閉じた時、メニューに戻る
        Navigator.of(context).pop();
      }
    }

    // _depthChangeScanCnt++;
    // if (_depthChangeScanCnt > DEPTH_CHANGE_SCAN) {
    //   _depthChangeScanCnt = 0;
    //   _depthChange = DEPTH_CHANGE_ORDERS[_depthChangeOrder]! +
    //       ((DEPTH_CHANGE_ORDERS[_depthChangeOrder]! - rand) / 10);
    //   debugPrint("深さ変化傾向" + _depthChange.toString());
    // }

    //時合の変化判定
    _jiaiChangeScanCnt++;
    if (_jiaiChangeScanCnt > JIAI_CHANGE_SCAN) {
      _jiaiChangeScanCnt = 0;
      //地合値の計算 0.5以下にはしない
      _jiai = 0.5 + (0.5 * (new math.Random()).nextDouble());
      debugPrint("時合度" + _jiai.toString());
    }

    //タナの変化判定
    _tanaChangeScanCnt++;
    if (_tanaChangeScanCnt > TANA_CHANGE_SCAN) {
      _tanaChangeScanCnt = 0;
      _justTana = (new math.Random()).nextDouble();
      debugPrint("タナ" + _justTana.toString());
    }

    _fishCardItem.forEach((cardFish) {
      cardFish.prob = 0.0;
    });

    //ジャーク継続スキャンカウントダウン
    _jerkCnt--;
    if (_jerkCnt < 0) {
      _jerkCnt = 0;
    }

    //船移動
    if (_moveShipTarget > _shipMove) {
      _shipMove += 0.05;
    }
    if (_moveShipTarget < _shipMove) {
      _shipMove -= 0.05;
    }
    //船移動の指示中
    if (_moveShipTarget != 0.5) {
      // if (_point > 0) {
      //   //ポイント消費
      //   _point -= SHIP_MOVE_POINT;
      // }
      // if (_point <= 0) {
      //   //ポイント切れ
      //   _point = 0;
      //   _moveShipTarget = 0.5;
      // }
      _shipMoveSeScan++;
      if (_shipMoveSeScan >= (800 / TIMER_INTERVAL).floor()) {
        //船動作音が連続再生しすぎるのを防止
        soundManagerPool.playSound('se/shipmove.mp3');
        _shipMoveSeScan = 0;
      }
    }
    if (!flgGoal) {
      //深さ変化度合の決定
      _depthChange = (_shipMove - 0.5) + ((_windLevel - 0.5) / 10);
      //深さ決定 船移動分と風分
      _maxDepth += _depthChange;
    } else {
      _depthChange = 0.0;
    }
    //深さ変化中
    if (_depthChange != 0.0) {
      //魚反応を移動させる
      fishPointerList.forEach((element) {
        //描画ごとにglovalkeyを付けているのでそれにアクセス
        try {
          RenderCustomPaint obj = element.painterKey.currentContext
              ?.findRenderObject() as RenderCustomPaint;
          FishPainter obj2 = obj.painter as FishPainter;
          //addxの値を加減算で移動
          obj2.addX += MOVE_FISHPOINTER_MAX * (_depthChange) * -1;
          obj2.addX += 0.5 - element.randMove;
        } catch (e) {}
      });
    }

    //座礁判定
    if (_maxDepth < 3.0) {
      //これ以上浅くいけない
      _maxDepth = 3.0;
      if (_moveShipTarget < 0.5) _moveShipTarget = 0.5;
    }

    //画像リストのMAX水深を更新
    lstImage.forEach((element) {
      //描画ごとにglovalkeyを付けているのでそれにアクセス
      try {
        RenderCustomPaint obj = element.painterKey.currentContext
            ?.findRenderObject() as RenderCustomPaint;
        ImagePainter obj2 = obj.painter as ImagePainter;
        //addxの値を加減算で移動
        obj2.nowMaxDepth = _maxDepth;
      } catch (e) {}
    });

    //HIT中
    if (_flgHit) {
      //暴れレベル変化判定
      if (rand < 0.05) {
        _abareLv = (new math.Random()).nextInt(_hitFish.abareLv) + 1;
        debugPrint(_abareLv.toString());
      }
      //残HP減算 暴れLv分減算
      _hitScanCnt -= _abareLv * 2;
      // //魚残HPの計算
      // if (_hitScanCnt > 0) {
      //   var minusHp = 1;
      //   //テンションが200以上
      //   if (_tension > 200.0) {
      //     //最大テンションとの差分の10分の1を補正として加算
      //     minusHp += ((_tension - _tensionValMax) / 10).floor();
      //   }
      //   //テンションが強いほどマイナス値を上げる
      //   //_hitScanCnt -= minusHp;
      // }
      if (_hitScanCnt < 0) _hitScanCnt = 0;
    }

    //テンションの処理
    num addVal = 0;
    var lureWeight = 0.0;
    var weight = 0.0;
    var mx = MAX_RAND_ADD_TENSION;
    var mn = MIN_RAND_ADD_TENSION;
    //使用中のルアー重さ
    lureWeight = uselureData.getWeight(uselureData.useWeightId);
    weight = lureWeight;
    if (_collect) {
      //高速回収中
      weight -= 1000;
      _onClutch = false;
    }
    if (_onClutch) {
      //クラッチON中
      weight -= 1000;
    }
    if (_flgBait || _flgHit) {
      //アタリかHIT中
      //アタリ中 or HIT中 テンション増減にHIT中補正をかける
      //var fish = FISH_TABLE.fishs[_fishidx];
      // mx += fish.addMax * (_hitScanCnt / fish.hp * _fishSize).round();
      // mn += fish.addMin * (_hitScanCnt / fish.hp * _fishSize).round();

      //魚重量
      var fishWeight = _hitFish.getWeight(_fishSize);
      //weight += (fish.abareWeight * (0.3 - rand) * (_hitScanCnt / fish.hp) * _fishSize;
      //暴れ重量 ((魚重量 * 暴れレベル) * rnd値 * 残HP割合
      var abareWeight =
          ((fishWeight * _abareLv) * rand) * (_hitScanCnt / _hitFish.hp);

      weight += fishWeight + abareWeight;
    } else {
      //アタリ中、HIT中でない時は現在の最大深さから可能性のある種を抽出
      _fishCardItem = FISH_TABLE.extractMaxDepth(maxDepth: _maxDepth);
    }
    //シャクリによるテンション増加 竿MAXテンションによって可変
    weight += _rodStandUp * (_tensionValMax * 1.5);

    //巻き中の時、重量に巻速度を加味
    if (_onTap) {
      weight = weight + (weight * (_speed / _speedValMax));
      //ハンドル回転の描画用
      _handleRoll += (_speed / _speedValMax) / 10;
      _handleRoll = (_handleRoll > 1.0) ? 0.0 : _handleRoll;
    }
    //浮力分調整（てきとーに２で割る）
    weight = weight / 2;
    //addVal = ((mx + 1 - mn) * rand).floor() + (mn) + (weight / 200);
    var tensionDiff = ((weight - _tension) * rand / 10).floor();
    addVal = tensionDiff;

    //現在深さの処理
    if (_collect) {
      //高速回収中
      _depth -= _maxDepth / 10;
    } else if (_onClutch) {
      //クラッチON中は強制的にテンション減算
      //水深を加算
      //ルアー重さによってフォール速度に補正をかける 20gの時0.1m/スキャン
      _depth += (lureWeight / 20);
    } else {
      if (_onTap) {
        //水深減算
        _depth = _depth - _speed / 300;
      } else {
        // if (!_flgBait && !_flgHit) {
        //   //巻いていない&釣れていない時はマイナス補正
        //   addVal -= HOSEI_MAX;
        //}
      }
      //debugPrint(_rodStandUp.toString());
      //シャクリによる水深減算
      _depth -= _rodStandUp;
    }

    if (addVal > 0) {
      //テンション+時は現在テンションによって補正をかける
      //addVal * ((TENSION_VAL_MAX - _tension) / TENSION_VAL_MAX);
      //二次関数 テンション上がるごとに上がりにくくする
      addVal = addVal +
          (addVal * -1) * (MathPow._getPow(3, (_tension / _tensionValMax)));
    }
    var val = _tension + addVal;

    //糸ダメージ判定
    if (val > _tensionValMax * 0.95) {
      _nowLineHp -= val - _tensionValMax * 0.95; //ラインHPを減らす
      if (_nowLineHp < 0) {
        //糸切れ
        debugPrint("いときれ");
        //メッセージ
        _centerTextMain = "糸が切れた!";
        _centerTextMainColor = Colors.red;
        _centerTextSub = "ルアーレベルダウン";
        _centerTextSubColor = Colors.yellow;
        startCenterInfo();
        //使用中のルアーを削除
        //haveTackle.lostLure(haveTackle.getUseLure().id);
        //使用中のルアーをレベルダウン
        uselureData.lvDown();
        val = 0.0;
        soundManagerPool.playSound('se/linebreak.mp3');
        nowBgm = Fishing.screenBgm;
        bgmPlay(nowBgm);

        _flgBait = false;
        _flgHit = false;
        _pointerColor = clsColor.getColorFromHex("ffd900");
        _nowDurationLv = POINT_DURATION_MSEC.length - 1;
        _rodStandUp = 0.0;
        _depth = 0.0;
      }
    }
    bool flgDrag = false;
    double dragDiff = 0.0;
    //ドラグ判定
    if (val > (_tensionValMax * _drag)) {
      //テンションとドラグレベルの差分
      dragDiff = val - (_tensionValMax * _drag);
      //ドラグ出た分深さを増やす？？？出すぎ？
      _depth = _depth + dragDiff / 300;
      //ドラグ出た分テンションを減らす？？？減らなすぎ？
      val = val - (dragDiff / 10);
      //テンションゲージの色を変える
      //_tensionActiveTrackColor = TENSION_COLOR_DRAG;
      flgDrag = true;

      //ドラグ音再生
      if (dragDiff > 15) {
        soundManagerPool.playSoundDisableContain(
            'se/drag2_high.mp3', enumDisableContainPlay.drag);
      } else {
        soundManagerPool.playSoundDisableContain(
            'se/drag2.mp3', enumDisableContainPlay.drag);
      }
    }

    if (val > _tensionValMax) val = _tensionValMax;
    if (val < TENSION_VAL_MIN) val = TENSION_VAL_MIN;

    if (_depth > _maxDepth) _depth = _maxDepth;
    if (_depth <= 0) {
      //深さ0m
      _depth = 0.0;
      if (_prevDepth > 0.0) {
        if (_flgHit) {
          soundManagerPool.playSound('se/waterupfish.mp3');
        } else {
          soundManagerPool.playSound('se/waterup.mp3');
        }
      }
      //ラインHPを回復
      _nowLineHp = _maxLineHp;
      //高速回収中フラグをリセット
      _collect = false;
    }
    _prevDepth = _depth;

    //テンション確定
    _tension = val;

    //テンションによってテンションバーの色を変える
    _tensionActiveTrackColor = clsColor.getColorRange(
        TENSION_COLOR_SAFE, TENSION_COLOR_DANGER, _tension, _tensionValMax);

    //水深表示
    _dispDepth = ((_depth).round() / 10).toStringAsFixed(1) +
        " / " +
        ((_maxDepth).round() / 10).toStringAsFixed(1) +
        ' m';

    // //使用中ルアーのHP減算
    // HaveLureModel lure = haveTackle.getUseLure();
    // //針は対象外
    // if (lure.lureId != 0) {
    //   //テンションに応じたダメージを与える
    //   lure.lureHp -= (_tension / 100).floor();
    //   if (lure.lureHp < 0.0) {
    //     //ルアーがめげた
    //     haveTackle.lostLure(lure.id);
    //     //メッセージ
    //     _centerTextMain = "BROKEN";
    //     _centerTextMainColor = Colors.blue;
    //     _centerTextSub = "ルアーが破壊!";
    //     _centerTextSubColor = Colors.yellow;
    //     startCenterInfo();
    //     soundManagerPool.playSound('se/lurebroken.mp3');
    //   }
    // }

    //光点表示位置設定
    // if (!settings.flgControlRight) {
    //   _lightSpotX = size.width * (2 / 3);
    // } else {
    //   _lightSpotX = size.width * (1 / 3);
    // }
    _lightSpotX = size.width / 2;
    // _lightSpotY =
    //     ((_depth / _maxDepth) * (size.height - _shoreHeight - _bottomHeight));
    _lightSpotY = ((_depth / _maxDepth) *
        (size.height - (_shoreHeight + 50) - _bottomHeight));

    //背景色
    if (_maxDepth < 100) {
      //水深10mまでは中層の範囲は固定
      _dispDepthLv1 = 1.0;
    } else {
      //水深150mで0.1にする
      _dispDepthLv1 = ((_maxDepth - 100) / 1400) * -0.9 + 1;
      //debugPrint(_dispDepthLv1.toString());
    }
    if (_maxDepth < 1000) {
      //水深10mまでは深層の範囲は固定
      _dispDepthLv2 = 1.0;
    } else {
      //水深500mで0.1にする
      _dispDepthLv2 = ((_maxDepth - 1000) / 4000) * -0.9 + 1;
    }

    //釣り上げ判定
    if (_flgHit && _depth <= 0) {
      _flgBait = false;
      _flgHit = false;
      _pointerColor = clsColor.getColorFromHex("ffd900");
      _nowDurationLv = POINT_DURATION_MSEC.length - 1;
      debugPrint("つりあげ");
      //var fish = FISH_TABLE.fishs[_fishidx];
      //debugPrint("おおきさ" + size.toString());
      var point = _hitFish.point + (_hitFish.point * _fishSize).floor();
      //初釣果判定
      var flgNew = true;
      fishesResult.listFishResult.forEach((val) {
        if (val.fishId == _hitFish.id) {
          flgNew = false;
          return;
        }
      });
      if (flgNew) point = point * 2; //初ゲットはポイント2倍

      //釣りあげ時のモーダル
      _timer.cancel(); //定周期タイマ停止
      bgmStop();

      var result = await showDialog<int>(
        context: context,
        barrierDismissible: false,
        builder: (_) {
          return Stack(
            children: [
              //釣りあげダイアログ
              fishGetDialog(
                dispSize: size,
                fish: _hitFish,
                fishSize: _fishSize,
                addPoint: point,
                flgNew: flgNew,
                uselureData: uselureData,
              ),
            ],
          );
        },
      );
      //モーダル閉じた時
      _depth = 0.0;
      _tension = 0.0;
      //ポイントを加算
      _point += point;
      //釣果リストに登録
      fishesResult.addResult(_hitFish.id, _fishSize);
      //魚種による成長
      switch (_hitFish.type) {
        case enumFishType.blue:
          //青物は最大テンション成長
          _tensionValMax += (point / 1);
          break;
        case enumFishType.bream:
          //鯛は最大巻き速度成長
          _speedValMax += (point / 10);
          break;
        case enumFishType.bottom:
          //底物は最大ライン強度成長
          _maxLineHp += (point / 10);
      }

      startTimer(); //定周期タイマ再開
      nowBgm = Fishing.screenBgm;
      bgmPlay(nowBgm);
    }

    //光点点滅速度関連の変数
    final durationMax = POINT_DURATION_MSEC[POINT_DURATION_MSEC.length - 1]!;
    final durationMin = POINT_DURATION_MSEC[0]!;
    var duration = POINT_DURATION_MSEC[_nowDurationLv]!;

    //現在底付近か？
    var bottom = (_depth > (_maxDepth * 0.8)) ? true : false;
    //深さから可能性のある種を抽出
    var fishs = FISH_TABLE.extractDepth(
        depth: _depth, maxDepth: _maxDepth, bottom: bottom);
    var maxProb = 0.0;
    duration = durationMax;

    if (!(_flgBait || _flgHit || _collect)) {
      var flgFall = false;
      var flgMaki = false;
      var flgJerk = false;
      //アタリ中でない時はアワセ判定値をリセット
      _fookingTension = 0.0;
      //現在の状態
      if (_depth > 0) {
        if (_jerkCnt > 0) {
          //ジャーク状態の継続
          flgJerk = true;
        } else {
          if (_onClutch && _depth < _maxDepth) {
            //糸出中、かつ水深MAXではない時はフォール中
            flgFall = true;
          } else if (!flgDrag && _rodStandUp > 0.5 && _depth < _maxDepth) {
            //ドラグ出中ではない、ロッド操作による補正中、水深0mやMAXではない時はジャーク中
            flgJerk = true;
            _jerkCnt = JERK_SCAN; //一度ジャークと判定されたら一定スキャン数ジャーク継続
          } else if (!flgDrag && _onTap && _depth < _maxDepth) {
            //ドラグ出中ではない、リーリング中、水深0mやMAXではない時は巻き中
            flgMaki = true;
          }
        }
      }

      if (flgFall || flgMaki || flgJerk) {
        //アタリ判定処理
        var hitTanaProb = 0.0;
        //HIT棚との差分
        final justTana = (_maxDepth * _justTana);
        var tanaDiff = (_depth - justTana).abs();
        //差分が範囲内か
        if (tanaDiff < _justTanaRange) {
          hitTanaProb =
              1.0 * ((tanaDiff - _justTanaRange).abs() / _justTanaRange);
        }
        if (hitTanaProb < 0.3) {
          hitTanaProb = 0.3; //棚範囲外の最低保証
        }

        //HIT率記憶用
        Map<int, double> mapProb = {};
        //種毎のHIT率計算ループ
        fishs.forEach((fish) {
          var hitSpeedprob = 0.0;
          var hitSpeedprobDisp = 0.0;
          var hitProb = 0.0;

          // //棚による大きさ補正値
          // var tanawari =
          //     (_maxDepth - fish.tanaMin) / (fish.tanaMax - fish.tanaMin);
          // tanawari = (tanawari < 0.1) ? 0.1 : tanawari;
          // tanawari = (tanawari > 0.9) ? 1.0 : tanawari;
          // //大きさ決定
          // var fishSize = (new math.Random()).nextDouble() * tanawari;
          //var fishSize = (new math.Random()).nextDouble();
          // //使用中ルアーサイズと魚大きさによる確率 魚サイズの1/4が適正値
          // var lureProb = 0.0;
          // if (lureData.size * 4 > fish.getSize(fishSize)) {
          //   lureProb = (lureData.size * 4) / fish.getSize(fishSize);
          // } else {
          //   lureProb = fish.getSize(fishSize) / (lureData.size * 4);
          // }
          var jiaiProb = 0.0;
          if (flgFall) {
            //フォール中のHIT率判定 魚のフォール志向 * ルアーのフォール能力
            hitSpeedprob = fish.hitFall * uselureData.fall;
            hitSpeedprobDisp = 0.0; //フォール中は巻き速度手本を見せない
            //フォールは時合の影響を半分にする
            jiaiProb = (1.0 + _jiai) / 2;
            //HIT確率の算出 フォールは時合の影響を半分にする
            // hitProb = (hitTanaProb * hitSpeedprob * ((1.0 + _jiai) / 2)) *
            //     fish.wariai /
            //     100;
            //フォール表示
            startJerk("ﾌｫｰﾙ中…");
          } else if (flgJerk) {
            //ジャーク中のHIT率判定 魚のジャーク志向 * ルアーのジャーク能力
            hitSpeedprob = fish.hitJerk * uselureData.jerk;
            hitSpeedprobDisp = 0.0; //ジャーク中は巻き速度手本を見せない
            //ジャークは時合の影響を1/3にする
            jiaiProb = (2.0 + _jiai) / 3;
            // //HIT確率の算出 ジャークは時合の影響を半分にする
            // hitProb = (hitTanaProb * hitSpeedprob * ((1.0 + _jiai) / 2)) *
            //     fish.wariai /
            //     100;

            //debugPrint("じゃーく" + hitSpeedprob.toString());
            //ジャーク表示
            startJerk("ｼｬｸﾘ!");
          } else if (flgMaki) {
            //巻き中のHIT率判定
            //HITスピードとの差分
            var speedDiff = (_speed - fish.hitSpeedJust).abs();
            //差分が範囲内か
            if (speedDiff < fish.hitSpeedRange) {
              //巻き中のHIT率判定 HITスピード理想値との乖離割合 * 魚の巻き志向 * ルアーの巻き能力
              hitSpeedprob = ((speedDiff - fish.hitSpeedRange).abs() /
                      fish.hitSpeedRange) *
                  fish.hitMaki *
                  uselureData.reeling;
            }
            if (hitSpeedprob < 0.01) {
              hitSpeedprob = 0.01; //速度範囲外の最低保証
            }
            hitSpeedprobDisp = hitSpeedprob;
            jiaiProb = _jiai;
            //フォール表示
            startJerk("巻き");
          }
          //HIT確率の算出
          hitProb = (hitTanaProb * hitSpeedprob * jiaiProb) * fish.wariai / 100;

          //魚IDごとに確率を記憶
          mapProb[fish.id] = hitProb;

          //全魚種で最も高い確率の取得
          if (hitTanaProb * hitSpeedprob > maxProb) {
            maxProb = hitTanaProb * hitSpeedprob * jiaiProb * fish.wariai;
          }
        });

        // //今釣れる魚リストに確率を格納
        // _fishCardItem.firstWhere((item) => item.id == fish.id).prob = hitProb;

        _fishCardItem.forEach((cardFish) {
          //確率計算した中に無い魚種の場合は確率0にして次へ
          if (!mapProb.containsKey(cardFish.id)) {
            cardFish.prob = 0.0;
          } else {
            //？？？mapのforEachにContinueがないのでelseで対応
            var prob = mapProb[cardFish.id];
            cardFish.prob = prob!;
            // //HIT判定ループ
            // mapProb.forEach((id, prob) {
            //1～0の乱数生成
            var hitrnd = (new math.Random()).nextDouble();
            if (DEBUGFLG) {
              //すぐつれる
              hitrnd = 0.0005;
            }

            //HIT判定
            if (prob > hitrnd) {
              //i 番目HIT
              _hitFish = FISH_TABLE.getFishDetail(cardFish.id);
              // //大きさ決定 今んとこ、単なるランダム？？？？？
              // _fishSize = (new math.Random()).nextDouble();
              //棚による大きさ補正値
              var tanawari = (_maxDepth - _hitFish.tanaMin) /
                  (_hitFish.tanaMax - _hitFish.tanaMin);
              //棚範囲の半分より上ならMAX
              tanawari = tanawari * 2;
              //最低でも1割
              tanawari = (tanawari < 0.1) ? 0.1 : tanawari;
              tanawari = (tanawari > 1.0) ? 1.0 : tanawari;
              //大きさ決定
              _fishSize = (new math.Random()).nextDouble() * tanawari;

              if (flgFall) {
                //フォール中のみアワセ時間を倍にする
                _baitCnt -= _hitFish.baitCntMax;
              } else {
                _baitCnt = 0;
              }
              _hitScanCnt = _hitFish.hp + (_hitFish.hp * _fishSize).floor();

              _abareLv = 0;
              //フッキング判定テンション
              _fookingTension = _tension + _hitFish.fookingTension;
              _fookingTension = (_fookingTension > _tensionValMax
                  ? _tensionValMax
                  : _fookingTension);
              //アタリと判定
              _flgBait = true;
              debugPrint("アタリ");
              //アワセ判定中フラグをリセット
              _flgFooking = false;
              _fookingTensionPrev = 0;
              _infoBackColor = TENSION_COLOR_DANGER;
              soundManagerPool.playSound('se/bait.mp3');
            }
            if (_flgBait || _flgHit) {
            } else {
              _infoBackColor = Colors.white;
              //HIT率に伴いポインタの色を変える？
              _pointerColor = clsColor.getColorFromHex("ffd900"); //？？？とりあえず黄色固定
            }
          }

          // //1～0の乱数生成
          // var hitrnd = (new math.Random()).nextDouble();
          // if (DEBUGFLG) {
          //   //すぐつれる
          //   hitrnd = 0.0005;
          // }
          //
          // //HIT判定
          // if (hitProb > hitrnd) {
          //   //i 番目HIT
          //   _fishidx = FISH_TABLE.fishs.indexOf(fish);
          //
          //   _fishSize = fishSize;
          //
          //   if (flgFall) {
          //     //フォール中のみアワセ時間を倍にする
          //     _baitCnt -= fish.baitCntMax;
          //   } else {
          //     _baitCnt = 0;
          //   }
          //   _hitScanCnt = fish.hp + (fish.hp * _fishSize).floor();
          //
          //   _abareLv = 0;
          //   //フッキング判定テンション
          //   _fookingTension = _tension + fish.fookingTension;
          //   _fookingTension = (_fookingTension > _tensionValMax
          //       ? _tensionValMax
          //       : _fookingTension);
          //   //アタリと判定
          //   _flgBait = true;
          //   debugPrint("アタリ");
          //   //アワセ判定中フラグをリセット
          //   _flgFooking = false;
          //   _fookingTensionPrev = 0;
          //   _infoBackColor = TENSION_COLOR_DANGER;
          //   soundManagerPool.playSound('se/bait.mp3');
          // }
          // if (_flgBait || _flgHit) {
          // } else {
          //   _infoBackColor = Colors.white;
          //   //HIT率に伴いポインタの色を変える？
          //   _pointerColor = clsColor.getColorFromHex("ffd900"); //？？？とりあえず黄色固定
          // }
        });
      }
    } else {
      //アタリ中またはHIT中の処理
      //var fish = FISH_TABLE.fishs[_fishidx];
      if (_flgBait) {
        //アタリ中
        if (!_flgFooking) {
          //合わせ成立前
          //当たってからのスキャン数加算
          _baitCnt++;
          if (_baitCnt > _hitFish.baitCntMax) {
            //アタリ判定期間終了
            //アワセ失敗
            _flgBait = false;
          } else {
            _pointerColor = clsColor.getColorFromHex("FF6A00"); //アタリ中はオレンジ
            //点滅速度最大
            duration = durationMin;
            if (_tension > _fookingTension) {
              //アワセモードに移行
              _flgFooking = true;
              _fookingTensionPrev = _tension;
            }
          }
        } else {
          //アワセモード中
          if (_fookingTensionPrev >= _tension) {
            //テンションが前回値以下の時、アワセ操作終了 = HIT成立
            _flgBait = false;
            _flgHit = true;
            //_fookingTension = 0.0;
            debugPrint('HIT!!!!');
            //_dispInfo = "HIT!";
            //フッキングの成功度
            _fookingLv = (_fookingTensionPrev - _fookingTension) / 2;
            //if (_fookingLv > 100.0) _fookingLv = 100.0;
            //最大テンションの半分が基本値 - フッキング成功度
            _fookingTension = (_tensionValMax / 2) - _fookingLv;
            bool flgOniAwase = false;
            if (_fookingTension < 0) {
              _fookingTension = 0;
              flgOniAwase = true;
            }
            //_fookingTension = _fookingTension < 20 ? 20 : _fookingTension;
            //HITメッセージ
            _centerTextMain = "HIT!";
            if (flgOniAwase) {
              _centerTextSub = "鬼アワセ";
              _centerTextMainColor = Colors.red;
            } else {
              _centerTextSub = "アワセLv " + _fookingLv.floor().toString();
              _centerTextSubColor = Colors.yellow;
            }
            startCenterInfo();

            soundManagerPool.playSound('se/hit.mp3');
            nowBgm = 'bgm_fight.mp3';
            bgmPlay(nowBgm);
          } else {
            //アワセ成立しないとき、テンションの今回値を記憶
            _fookingTensionPrev = _tension;
          }
        }
      } else {
        if (_flgHit) {
          //HIT中の処理
          _pointerColor = clsColor.getColorFromHex("ff0000"); //HIT中は赤固定表示

          //テンションから点滅速度を算出
          duration = durationMax -
              ((durationMax - durationMin) * (_tension / _tensionValMax))
                  .floor();

          //バレ判定
          //基本値 MAX2000の時0.5
          var bare = _tensionValMax / 10000;
          //底にいるとき4倍
          if (_depth >= _maxDepth) bare = bare * 4;
          //テンションがアワセ値未満の時3倍
          //if (val < _fookingTension) bare = bare * 3;
          //現在テンションによって補正 少ないほど早い 0の時2倍
          bare = bare * (2 * (1.0 - (_tension / _tensionValMax)));
          //魚種による補正 MAXのとき3倍
          bare = bare * (10 * _hitFish.bareEasy);
          //ドラグ出た分だけ上昇
          bare = bare + dragDiff / 75;

          _fookingTension += bare;

          if (_fookingTension > _tensionValMax) {
            //バレ条件成立が一定スキャン保持でバレとする
            debugPrint("バレ");
            _flgBait = false;
            _flgHit = false;
            //バレメッセージ
            _centerTextMain = "";
            _centerTextMainColor = Colors.blue;
            _centerTextSub = "バレました";
            _centerTextSubColor = Colors.blue;
            startCenterInfo();

            nowBgm = Fishing.screenBgm;
            bgmPlay(nowBgm);
            _bareCnt = 0;
          }
        }
      }
    }

    //シャクリ値を減算
    if (_rodStandUp > 0.0) {
      _rodStandUp -= 0.5; //1スキャン毎に0.5ずつ消える
    }
    if (_rodStandUp < 0.0) {
      //マイナスになったら0にする
      _rodStandUp = 0.0;
    }

    duration = duration > durationMax ? durationMax : duration;
    duration = duration < durationMin ? durationMin : duration;
    //今回の点滅速度レベル 初期値は最大値
    var newDurationLv = POINT_DURATION_MSEC.length - 1;
    for (var lv = 0; lv < POINT_DURATION_MSEC.length; lv++) {
      var d = POINT_DURATION_MSEC[lv]!;
      if (d > duration) {
        newDurationLv = lv;
        break;
      }
    }
    //debugPrint(newDurationLv.toString());
    //点滅速度レベルが変化した？
    if (newDurationLv != _nowDurationLv || _ligntSpotAnimationChangeing) {
      if (ligntSpotAnimation(
          false, POINT_DURATION_MSEC[newDurationLv] as int)) {
        //今回のアニメーションが止まってから変化させる
        _nowDurationLv = newDurationLv;
      }
    }

    //沖合何kmを計算
    offShore = _maxDepth * 7 / 1000;

    var tanarnd = (new math.Random()).nextDouble();
    //棚を示す光点の表示
    var hannornd = (new math.Random()).nextDouble();
    if (hannornd > 0.96 && _jiai > tanarnd) {
      var fishy = _sonarTop + (_sonarHeight * _justTana);
      //レンジ分バラケ
      var barakeLevel = 4; //バラケ度
      var barake = (_justTanaRange * ((0.5 - tanarnd) * barakeLevel));
      fishy = fishy + barake;
      fishy = (fishy < _shoreHeight) ? _shoreHeight : fishy;
      fishy = (fishy > _shoreHeight + _sonarHeight)
          ? _shoreHeight + _sonarHeight
          : fishy;
      generateFishPointer(fishy, 20.0);
    }

    //タックルの描画
    if (!settings.flgControlRight) {
      _tackleCenterX = 80.0;
      _takcleChangeButtonPosition = MainAxisAlignment.end;
    } else {
      _takcleChangeButtonPosition = MainAxisAlignment.start;
      _tackleCenterX = size.width - 80.0;
    }
    _rodSizeX = 20.0;
    _rodSizeY = size.height - _shoreHeight;
    _reelSizeX = 60.0;
    _reelSizeY = 60.0;
    _reelCenterY = size.height - 60 - 40;

    //debugPrint(_tension.toString());
    setState(() {});
  }

  @override
  Widget buildChildWidget(BuildContext context) {

    // <-- 通常のbuildメソッドの代わりに実装
    //画面サイズ取得用
    final Size size = MediaQuery.of(context).size;
    return Material(
        child: Scaffold(
            // appBar: AppBar(
            //   title: Row(mainAxisAlignment: MainAxisAlignment.center, children: [
            //     Text("環境設定"),
            //   ]),
            //   leading: IconButton(
            //     // 戻るアイコン
            //     icon: Icon(Icons.arrow_back),
            //     color: Colors.white,
            //     iconSize: 30.0,
            //     onPressed: () {
            //       //前画面に戻る
            //       Navigator.of(context).pop();
            //     },
            //   ),
            // ),
            extendBodyBehindAppBar: true, // <--- ここ

            appBar: AppBar(
              // title: Row(mainAxisAlignment: MainAxisAlignment.center, children: [
              //   Text("環境設定"),
              // ]),
              backgroundColor:
                  clsColor.getColorFromHex("FFFFFF").withOpacity(0.1),
              //title: Text(_senchoMessage),
              //左上
              leading: Row(
                children: [
                  IconButton(
                    // 図鑑アイコン
                    icon: Icon(Icons.menu_book),
                    color: Colors.white,
                    iconSize: 30.0,
                    onPressed: () async {
                      _timer.cancel(); //定周期タイマ停止
                      // //図鑑モーダルの表示
                      soundManagerPool.playSound('se/book.mp3');
                      var result = await showDialog<int>(
                        context: context,
                        barrierDismissible: false,
                        builder: (_) {
                          return BookDialog(
                            fishsTable: FISH_TABLE,
                            fishesResult: fishesResult,
                            bgm: super.bgm,
                          );
                        },
                      );
                      soundManagerPool.playSound('se/bookclose.mp3');
                      startTimer(); //定周期タイマ再開
                      bgmPlay(nowBgm);

                      setState(() {});
                    },
                  ),
                ],
              ),
              title:
                  // Row(
                  //   mainAxisAlignment: MainAxisAlignment.center,
                  //   children: [
                  //     Text('沖合' + offShore.toStringAsFixed(1) + 'km'),
                  //   ],
                  // ),
                  Stack(
                children: [
                  Container(
                    margin: EdgeInsets.only(top: 10, left: 15),
                    child: new Image(
                      key: grobalKeyMinimap,
                      image: AssetImage('assets/images/minimap.png'),
                      //width: 60,
                      height: _appBarHeight - 10,
                    ),
                  ),
                  Container(
                    margin: EdgeInsets.only(
                        top: 10, left: (_minimapWidth * (_maxDepth / _maximumDepth))),
                    child: new Image(
                      image: AssetImage('assets/images/ship.png'),
                      //width: 30,
                      height: 15,
                    ),
                  ),
                ],
              ),
              //右（複数可）
              actions: <Widget>[
                Container(
                    // margin: EdgeInsets.only(right: 10),
                    // child: ElevatedButton(
                    //   child: Column(
                    //       mainAxisAlignment: MainAxisAlignment.end,
                    //       children: [
                    //         Icon(
                    //           Icons.shopping_cart,
                    //           color: Colors.white,
                    //           size: 30.0,
                    //         ),
                    //         Text(
                    //           _point.toString() + "円",
                    //         ),
                    //       ]),
                    //   onPressed: () async {
                    //     //買い物モーダルの表示
                    //     _timer.cancel(); //定周期タイマ停止
                    //     soundManagerPool.playSound('se/book.mp3'); //音は仮
                    //     int? result = await showDialog<int>(
                    //       context: context,
                    //       barrierDismissible: false,
                    //       builder: (_) {
                    //         return ShopDialog(
                    //           haveTakcle: haveTackle,
                    //           originPoint: _point,
                    //           bgm: super.bgm,
                    //         );
                    //       },
                    //     );
                    //     _point = result!;
                    //     soundManagerPool.playSound('se/bookclose.mp3'); //音は仮
                    //     startTimer(); //定周期タイマ再開
                    //     bgmPlay(nowBgm);
                    //     setState(() {});
                    //   },
                    //),
                    ),
                Container(
                    child: ElevatedButton(
                  child: Column(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        Icon(
                          Icons.settings,
                          color: Colors.white,
                          size: 30.0,
                        ),
                        Text("設定"),
                      ]),
                  onPressed: () async {
                    //買い物モーダルの表示
                    _timer.cancel(); //定周期タイマ停止
                    bgmStop();
                    //subBgmLoop('bgm/bgm_book.mp3');
                    //soundManagerPool.playSound('se/book.mp3'); //音は仮
                    int? result = await showDialog<int>(
                      context: context,
                      barrierDismissible: false,
                      builder: (_) {
                        return SettingDialog(
                          bgm: super.bgm,
                        );
                      },
                    );
                    //soundManagerPool.playSound('se/bookclose.mp3'); //音は仮
                    startTimer(); //定周期タイマ再開
                    bgmPlay(nowBgm);
                    setState(() {});
                  },
                )),
              ],
            ),
            //endDrawer: DrawerItem(),

            // body: SafeArea(
            //   child: SpriteWidget(
            //     RootNode(size),
            //   ),
            // ),

            body: GestureDetector(
                //ドラッグ操作が開始された時
                onPanStart: (DragStartDetails details) {
                  debugPrint("ドラッグ開始");
                  if (_showTacleChangeDialog) {
                    soundManagerPool.playSound('se/boxclose.mp3');
                    _showTacleChangeDialog = false;
                  }
                  _cursorX = details.localPosition.dx;
                  _cursorY = details.localPosition.dy;
                  //クラッチOFF時、タップ箇所がクラッチ部分か？
                  if (!_onClutch &&
                      //リールをタップで
                      _cursorX > _tackleCenterX - _reelSizeX &&
                      _cursorX < _tackleCenterX + _reelSizeX &&
                      _cursorY > _reelCenterY - _reelSizeY &&
                      _cursorY < _reelCenterY + _reelSizeY) {
                    chengeClutch(true);
                    return;
                  }

                  chengeClutch(false);
                  _onTap = true;
                  //タップ時の画面エフェクト
                  offset = Offset(
                      details.globalPosition.dx, details.globalPosition.dy);
                  generateTapPointer(details);

                  //タップ時はスピードスライダの色替え
                  _speedActiveTrackColor = SPEED_COLOR_REELING;
                },
                //ドラッグ操作で位置が変化した時
                onPanUpdate: (DragUpdateDetails details) {
                  if (size.isEmpty) {
                    return;
                  }
                  if (!_onTap) {
                    return;
                  }
                  //現在の座標を取得する
                  var mX = details.localPosition.dx; //X座標
                  var mY = details.localPosition.dy; //Y座標
                  //初期位置から動いた値を取得
                  var moveX = mX - _cursorX;
                  var moveY = mY - _cursorY;
                  //x座標記憶を更新
                  _cursorX = mX;
                  _cursorY = mY;
                  //巻き速度値の計算
                  //var addVal = (moveX / (1000 / 2) * _speedValMax);
                  //X軸の移動距離を 20～400の範囲で割った値（環境設定によって可変）
                  var addVal = moveX /
                      (20 + (180 * (1.0 - settings.makiSense))) *
                      _speedValMax;
                  var val = _speed + addVal;
                  if (val > _speedValMax) val = _speedValMax;
                  if (val < SPEED_VAL_MIN) val = SPEED_VAL_MIN;
                  _speed = val;
                  //アワセ値
                  //addVal = (moveY / 100);
                  debugPrint(settings.jerkSense.toString());
                  //Y軸の移動距離を 40～150の範囲で割った値（環境設定によって可変）
                  addVal = moveY / (40 + (110 * (1.0 - settings.jerkSense)));
                  val = _rodStandUp + addVal;
                  if (val > ROD_STANDUP_MAX) val = ROD_STANDUP_MAX;
                  if (val < 0) val = 0;
                  _rodStandUp = val;
                  if (_rodStandUp > 4.0) {
                    //シャクリ音（大）
                    soundManagerPool.playSoundDisableContain(
                        'se/middlejerk.mp3', enumDisableContainPlay.jerk);
                  } else if (_rodStandUp > 2.0) {
                    //シャクリ音（小）
                    soundManagerPool.playSoundDisableContain(
                        'se/lowjerk.mp3', enumDisableContainPlay.jerk);
                  }
                },
                //タップ、ドラッグ操作が終了した時
                onPanEnd: (DragEndDetails details) {
                  debugPrint("タップはなし");
                  _onTap = false;
                  //スピードスライダの色を戻す
                  _speedActiveTrackColor = SPEED_COLOR;
                },
                child: Container(
                    //key: globalKeyShore,
                    //margin: EdgeInsets.only(bottom: 50),
                    decoration: BoxDecoration(
                        gradient: LinearGradient(
                      begin: FractionalOffset.topCenter,
                      end: FractionalOffset.bottomCenter,
                      colors: [
                        clsColor.getColorFromHex("5495FF"),
                        clsColor.getColorFromHex("EFFAFF")
                      ],
                      stops: const [
                        0.0,
                        0.3,
                      ],
                    )),
                    child: new Stack(children: <Widget>[
                      if (flgDispSettingsOk)
                        (lstImage.isNotEmpty)
                            ? Stack(children: lstImage)
                            : Container(),
                      // Stack(
                      //   children: [
                      //     if (lstImage[0].flgDisp)
                      //       Container(
                      //         //margin: EdgeInsets.only(top: _shoreHeight),
                      //         width: double.infinity,
                      //         height: double.infinity,
                      //         child: CustomPaint(
                      //           painter: new imagePainter(
                      //               dispSize: size,
                      //               //imagePath: 'assets/images/teibou.png',
                      //               image: lstImage[0].image,
                      //               top: lstImage[0].top,
                      //               left: lstImage[0].left,
                      //               width: lstImage[0].width,
                      //               height: lstImage[0].height),
                      //         ),
                      //       ),
                      //   ],
                      // ),
                      Column(children: <Widget>[
                        //海上
                        Container(
                          key: globalKeyShore,
                          //margin: EdgeInsets.only(bottom: 50),
                          // decoration: BoxDecoration(
                          //     gradient: LinearGradient(
                          //   begin: FractionalOffset.topCenter,
                          //   end: FractionalOffset.bottomCenter,
                          //   colors: [
                          //     clsColor.getColorFromHex("5495FF"),
                          //     clsColor.getColorFromHex("EFFAFF")
                          //   ],
                          //   stops: const [
                          //     0.0,
                          //     1.0,
                          //   ],
                          // )),
                          child: Column(children: <Widget>[
                            Container(
                                //appBarは透過なのでその分の高さを加算
                                margin:
                                    EdgeInsets.only(top: _appBarHeight + 10),
                                height: 40,
                                //テンションとドラグレベルのスライダーをstackで重ねて表示
                                child: new Stack(children: <Widget>[
                                  // //テンションスライダー
                                  Container(
                                      margin:
                                          EdgeInsets.only(left: 10, right: 10),
                                      //color: Colors.white,
                                      child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: <Widget>[
                                            //Text("TENSION/DRAG"),
                                            Row(
                                              mainAxisAlignment:
                                                  MainAxisAlignment
                                                      .spaceBetween,
                                              crossAxisAlignment:
                                                  CrossAxisAlignment.start,
                                              children: [
                                                new Image(
                                                  image: AssetImage(
                                                      'assets/images/TENSIONDRAG.png'),
                                                ),
                                              ],
                                            ),
                                            Container(
                                              margin: EdgeInsets.only(left: 8),
                                              child: Transform(
                                                transform: Matrix4.skewX(-0.3),
                                                child: new Stack(children: <
                                                    Widget>[
                                                  CustomPaint(
                                                    painter: new SliderPainter(
                                                      height: 20,
                                                      activeColor:
                                                          _tensionActiveTrackColor,
                                                      inactiveColor: (_flgHit)
                                                          ? Colors.black
                                                          : Colors.white,
                                                      value: _tension,
                                                      maxValue: _tensionValMax,
                                                      backRadius:
                                                          _animationRadius
                                                              .value,
                                                      maxBackRadius:
                                                          POINTER_BACK_SIZE,
                                                      flgShaKe: (_flgBait ||
                                                              (_tension >
                                                                  (_tensionValMax *
                                                                      _drag)))
                                                          ? true
                                                          : false,
                                                      flgDispValue: true,
                                                      flgDispMaxValue: true,
                                                      value2: _fookingTension,
                                                      value2Color: Colors.black
                                                          .withOpacity(0.3),
                                                    ),
                                                    child: Container(),
                                                  ),
                                                  // Container(
                                                  //   margin:
                                                  //       EdgeInsets.only(left: 10 + 400),
                                                  //   child: new Image(
                                                  //     image: AssetImage(
                                                  //         'assets/images/denryu.gif'),
                                                  //     height: 30,
                                                  //   ),
                                                  // ),
                                                ]),
                                              ),
                                            ),
                                          ])),
                                  //ドラグスライダー
                                  Container(
                                    margin: EdgeInsets.only(top: 16),
                                    height: 40,
                                    child: SliderTheme(
                                        data: SliderTheme.of(context).copyWith(
                                          //trackHeight: 1, //全体の縦長
                                          valueIndicatorColor: Colors.black
                                              .withOpacity(0.0), //背景の色
                                          activeTrackColor: Colors.black
                                              .withOpacity(0.0), //値有りエリアの色
                                          inactiveTrackColor: Colors.black
                                              .withOpacity(0.0), //値無しエリアの色
                                          activeTickMarkColor: Colors.black
                                              .withOpacity(0.0), //各value値の色
                                          thumbColor: Colors.red
                                              .withOpacity(0.5), //値ツマミの色
                                          thumbShape: RoundSliderThumbShape(
                                              enabledThumbRadius: 10), //ツマミの大きさ
                                          overlayColor: Colors.black
                                              .withOpacity(0.0), //値ツマミフォーカス時の色
                                        ),
                                        child: Slider(
                                          value: _drag,
                                          min: 0.0,
                                          max: 1.0,
                                          divisions:
                                              (_tensionValMax - TENSION_VAL_MIN)
                                                  .floor(),
                                          onChanged: (double value) {
                                            setState(() {
                                              _drag = value;
                                            });
                                          },
                                        )),
                                  )
                                ])),
                            //ラインHPスライダー
                            Container(
                                margin: EdgeInsets.only(
                                    left: 10, right: 10, bottom: 5),
                                height: 5,
                                child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: <Widget>[
                                      CustomPaint(
                                        painter: new SliderPainter(
                                          height: 10,
                                          activeColor: LINE_HP_COLOR,
                                          inactiveColor: Colors.white,
                                          value: _nowLineHp,
                                          maxValue: _maxLineHp,
                                          backRadius: 0,
                                          maxBackRadius: 0,
                                          flgShaKe: false,
                                          flgDispValue: true,
                                          flgDispMaxValue: false,
                                        ),
                                        child: Container(),
                                      ),
                                    ])),

                            //巻速度スライダー
                            Container(
                                margin: EdgeInsets.only(left: 10, right: 10),
                                height: 40,
                                child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: <Widget>[
                                      //Text("SPEED"),
                                      new Image(
                                        image: AssetImage(
                                            'assets/images/SPEED.png'),
                                      ),
                                      Container(
                                        margin: EdgeInsets.only(left: 8),
                                        child: Transform(
                                          transform: Matrix4.skewX(-0.3),
                                          child: CustomPaint(
                                            painter: new SliderPainter(
                                              height: 20,
                                              activeColor:
                                                  _speedActiveTrackColor,
                                              inactiveColor: Colors.white,
                                              value: _speed,
                                              maxValue: _speedValMax,
                                              backRadius: 0,
                                              maxBackRadius: 0,
                                              flgShaKe: false,
                                              flgDispValue: true,
                                              flgDispMaxValue: true,
                                            ),
                                            child: Container(),
                                          ),
                                        ),
                                      ),
                                      //可能性のある魚種の速度範囲表示
                                    ])),
                          ]),
                        ),
                        //海中
                        Expanded(
                            child: Container(
                                margin: EdgeInsets.only(top: 50),
                                decoration: BoxDecoration(
                                    border: Border.all(
                                        color:
                                            clsColor.getColorFromHex("02D5F2")),
                                    //color: clsColor.getColorFromHex("200070"),
                                    gradient: LinearGradient(
                                      begin: FractionalOffset.topCenter,
                                      end: FractionalOffset.bottomCenter,
                                      colors: [
                                        clsColor.getColorFromHex("02D5F2"),
                                        clsColor.getColorFromHex("013367"),
                                        clsColor.getColorFromHex("002142"),
                                        clsColor.getColorFromHex("000000"),
                                      ],
                                      stops: [
                                        0.0,
                                        _dispDepthLv1,
                                        _dispDepthLv2,
                                        1.0
                                      ],
                                    )),
                                child: Column(children: <Widget>[
                                  //ソナー画面
                                  Expanded(
                                    //描画エリア
                                    child: Container(
                                      key: globalKeySonar,
                                      child: Stack(children: <Widget>[
                                        //ソナー光点
                                        Container(
                                          width: size.width,
                                        ),
                                        //ジャーク時のテキスト
                                        if (_jerkTextAnimationController
                                            .isAnimating)
                                          Container(
                                            //width: 30,
                                            margin: EdgeInsets.only(
                                                top: _lightSpotY -
                                                    ((_lightSpotY < 18.0)
                                                        ? _lightSpotY
                                                        : (18.0 +
                                                            _jerkTextLocation
                                                                .value)),
                                                left: _lightSpotX +
                                                    (10.0 *
                                                        _jerkTextLocation
                                                            .value)),
                                            child: Text(
                                              _actionText,
                                              style: TextStyle(
                                                  color: Colors.red,
                                                  fontWeight: FontWeight.bold),
                                            ),
                                          ),

                                        //魚HPスライダ
                                        Visibility(
                                          visible: _flgHit,
                                          child: Container(
                                            width: 30,
                                            margin: EdgeInsets.only(
                                                top: _lightSpotY -
                                                    ((_lightSpotY < 18.0)
                                                        ? _lightSpotY
                                                        : 18.0),
                                                left: _lightSpotX - 18.0),
                                            child: CustomPaint(
                                              painter: new SliderPainter(
                                                height: 5,
                                                activeColor: clsColor
                                                    .getRaitoColor(_hitScanCnt /
                                                        (_hitFish.hp +
                                                            (_hitFish.hp *
                                                                _fishSize))),
                                                inactiveColor: Colors.white,
                                                value: _hitScanCnt.toDouble(),
                                                maxValue: (_hitFish.hp +
                                                    (_hitFish.hp * _fishSize)),
                                                backRadius: 0,
                                                maxBackRadius: 0,
                                                flgShaKe: false,
                                                flgDispValue: false,
                                                flgDispMaxValue: false,
                                              ),
                                              child: Container(),
                                            ),
                                          ),
                                        ),
                                      ]),
                                    ),
                                  )
                                ]))),

                        //海底
                        Container(
                            key: globalKeyBottom,
                            height: 60,
                            decoration: BoxDecoration(

                                //color: clsColor.getColorFromHex("200070"),
                                gradient: LinearGradient(
                              begin: FractionalOffset.topCenter,
                              end: FractionalOffset.bottomCenter,
                              colors: [
                                clsColor.getColorFromHex("758661"),
                                clsColor.getColorFromHex("455E42"),
                                clsColor.getColorFromHex("0A081F"),
                              ],
                              stops: [0.0, 0.6, 1.0],
                            )),
                            //画面下部
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: <Widget>[
                                Column(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    Container(
                                      width: size.width / 3,
                                      child: (settings.flgControlRight)
                                          ? //_tacklePositionChangeButton()
                                          Row(
                                              children: [
                                                Container(
                                                  margin: EdgeInsets.only(
                                                      left: 10, right: 10),
                                                  padding:
                                                      const EdgeInsets.all(5.0),
                                                  decoration: BoxDecoration(
                                                      border: Border.all(
                                                          color: Colors.red,
                                                          width: 3),
                                                      color: Colors.white),
                                                  child: Text(_dispDepth,
                                                      style: TextStyle(
                                                        color: Colors.black,
                                                        fontWeight:
                                                            FontWeight.bold,
                                                        fontSize: 14,
                                                      )),
                                                ),
                                              ],
                                            )
                                          : Text(''),
                                    ),
                                  ],
                                ),
                                Column(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: <Widget>[
                                    Container(
                                        width: size.width / 3,
                                        child: Container()),
                                  ],
                                ),
                                Column(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    Container(
                                      width: size.width / 3,
                                      child: (!settings.flgControlRight)
                                          ? //_tacklePositionChangeButton()
                                          Row(
                                              children: [
                                                Container(
                                                  margin: EdgeInsets.only(
                                                      left: 10, right: 10),
                                                  padding:
                                                      const EdgeInsets.all(5.0),
                                                  decoration: BoxDecoration(
                                                      border: Border.all(
                                                          color: Colors.red,
                                                          width: 3),
                                                      color: Colors.white),
                                                  child: Text(_dispDepth,
                                                      style: TextStyle(
                                                        color: Colors.black,
                                                        fontWeight:
                                                            FontWeight.bold,
                                                        fontSize: 14,
                                                      )),
                                                ),
                                              ],
                                            )
                                          : Text(''),
                                    ),
                                  ],
                                ),
                              ],
                            )),
                      ]),
                      //画面全体的に描画するもの
                      Stack(children: <Widget>[
                        Row(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Container(
                                margin: EdgeInsets.only(
                                  top: _shoreHeight +
                                      20 -
                                      //(math.sin(
                                      // waveController.value * 0.5 * math.pi)),

                                      ((waveController.value < 0.5)
                                          ? 7 * waveController.value * 2
                                          : (7 *
                                                  (waveController.value - 0.5) *
                                                  -2) +
                                              7),
                                  //left: math.sin(waveController.value * math.pi)
                                ),
                                child: GestureDetector(
                                  onTap: () async {
                                    setState(() {});
                                  },
                                  //船の描画
                                  child: Transform.rotate(
                                    //angle: 45 * math.pi / 180,
                                    angle: (405 - (90 * _shipMove)) *
                                        math.pi /
                                        180,
                                    child: new Image(
                                      image:
                                          AssetImage('assets/images/ship.png'),
                                      width: 60,
                                      height: 30,
                                    ),
                                  ),
                                ),
                              ),
                            ]),
                        Container(
                            height: 40,
                            margin: EdgeInsets.only(
                              top: (_shoreHeight + 10),
                            ),
                            child: AnimatedBuilder(
                              animation: waveController, // waveControllerを設定
                              builder: (context, child) => Stack(
                                children: <Widget>[
                                  //？？？iPhoneのsafariで描画できない,androidはOK
                                  // 1つ目の波
                                  ClipPath(
                                    child: Container(
                                        color: clsColor
                                            .getColorFromHex("02D5F2")
                                            .withOpacity(1.0)),
                                    clipper: WaveClipper(
                                        context, waveController.value, 0),
                                  ),
                                  // 2つ目の波
                                  ClipPath(
                                    child: Container(
                                        color: clsColor
                                            .getColorFromHex("02D5F2")
                                            .withOpacity(0.3)),
                                    clipper: WaveClipper(
                                        context, waveController.value, 0.5),
                                  ),
                                  // ↑ 追加部分
                                ],
                              ),
                            )),
                        AnimatedOpacity(
                            opacity: (_depth > 0.0 || _point <= 0) ? 0.0 : 1.0,
                            duration: Duration(milliseconds: 200),
                            child: Container(
                                margin: EdgeInsets.only(
                                    top: _shoreHeight, left: 10, right: 10),
                                child: Row(
                                  mainAxisAlignment:
                                      MainAxisAlignment.spaceBetween,
                                  children: [
                                    GestureDetector(
                                      //タップ開始
                                      onTapDown: (details) {
                                        soundManagerPool
                                            .playSound('se/engineon.mp3');
                                        _shipMoveSeScan = 0;
                                        if (_depth <= 0.0) {
                                          setState(() {
                                            _moveShipTarget = 0.3;
                                          });
                                        }
                                      },
                                      //タップ終了
                                      onTapUp: (details) {
                                        setState(() {
                                          _moveShipTarget = 0.5;
                                        });
                                      },
                                      //タップしたままフォーカス外れた時
                                      onTapCancel: () {
                                        setState(() {
                                          _moveShipTarget = 0.5;
                                        });
                                      },
                                      child: new Image(
                                        image: AssetImage(
                                            'assets/images/arrow_left.png'),
                                        height: 30,
                                      ),
                                    ),
                                    GestureDetector(
                                      //タップ開始
                                      onTapDown: (details) {
                                        soundManagerPool
                                            .playSound('se/engineon.mp3');
                                        if (_depth <= 0.0) {
                                          setState(() {
                                            _moveShipTarget = 0.7;
                                          });
                                        }
                                      },
                                      //タップ終了
                                      onTapUp: (details) {
                                        setState(() {
                                          _moveShipTarget = 0.5;
                                        });
                                      },
                                      //タップしたままフォーカス外れた時
                                      onTapCancel: () {
                                        setState(() {
                                          _moveShipTarget = 0.5;
                                        });
                                      },
                                      child: new Image(
                                        image: AssetImage(
                                            'assets/images/arrow_right.png'),
                                        height: 30,
                                      ),
                                    ),
                                  ],
                                ))),
                        //]),

                        //ソナー光点
                        Container(
                          width: size.width,
                          margin: EdgeInsets.only(
                              top: _shoreHeight + 50 + _lightSpotY,
                              left: _lightSpotX),
                          child: CustomPaint(
                            painter: LightSpot(POINTER_SIZE, POINTER_BACK_SIZE,
                                _animationRadius.value, _pointerColor, 0, 0),
                          ),
                        ),
                        //タップ時の光点
                        (tapPointerList.isNotEmpty)
                            ? Stack(children: tapPointerList)
                            : Container(),
                        //反応光点
                        (fishPointerList.isNotEmpty)
                            ? Stack(children: fishPointerList)
                            : Container(),
                        //タックルの描画
                        CustomPaint(
                          painter: new tacklePainter(
                            shoreHeight: _shoreHeight,
                            dispSize: size,
                            takclePositionRight: settings.flgControlRight,
                            tackleCenterX: _tackleCenterX,
                            rodSizeX: _rodSizeX,
                            rodSizeY: _rodSizeY,
                            reelSizeX: _reelSizeX,
                            reelSizeY: _reelSizeY,
                            reelCenterY: _reelCenterY,
                            clutchBackColor:
                                (_onClutch ? Colors.lightBlue : Colors.red),
                            rodStandUp: _rodStandUp,
                            rodTension: _tension / _tensionValMax,
                            clutchTextSize: (_onClutch
                                ? 0.0
                                : 20 * (_clutchAnime.value + 3.0) / 4),
                            handleRoll: _handleRoll,
                          ),
                        ),
                        if (_centerTextAnimationController.isAnimating)
                          Container(
                              margin: EdgeInsets.only(
                                  left: _centerTextLeft.value,
                                  top: size.height / 2),
                              child: Column(
                                children: [
                                  Text(
                                    _centerTextMain,
                                    textAlign: TextAlign.center,
                                    style: TextStyle(
                                        color: _centerTextMainColor
                                            .withOpacity(0.8),
                                        fontWeight: FontWeight.bold,
                                        fontSize: 100,
                                        fontFamily: 'OpenSans',
                                        fontStyle: FontStyle.italic,
                                        shadows: <Shadow>[
                                          Shadow(
                                              offset: Offset(5.0, 10.0),
                                              blurRadius: 2.0,
                                              color:
                                                  Colors.black.withOpacity(0.8))
                                        ]),
                                  ),
                                  Text(
                                    _centerTextSub,
                                    style: TextStyle(
                                        color: _centerTextSubColor
                                            .withOpacity(0.8),
                                        fontWeight: FontWeight.bold,
                                        fontSize: 40,
                                        fontFamily: 'OpenSans',
                                        fontStyle: FontStyle.italic,
                                        shadows: <Shadow>[
                                          Shadow(
                                              offset: Offset(5.0, 10.0),
                                              blurRadius: 2.0,
                                              color:
                                                  Colors.black.withOpacity(0.8))
                                        ]),
                                  ),
                                ],
                              )),
                        //UI関係
                        Column(
                          mainAxisAlignment: MainAxisAlignment.start,
                          children: [
                            Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                (!settings.flgControlRight)
                                    ?
                                    //回収ボタン ？？？デザインは仮だから
                                    AnimatedOpacity(
                                        opacity: _depth > 0.0 &&
                                                !_flgBait &&
                                                !_flgHit
                                            ? 1.0
                                            : 0.0,
                                        duration: Duration(milliseconds: 200),
                                        child: Container(
                                          margin: EdgeInsets.only(
                                              top: _shoreHeight + 50, left: 10),
                                          child: ElevatedButton(
                                              child: const Text('回収'),
                                              style: ElevatedButton.styleFrom(
                                                primary: Colors.amber, //背景色
                                                onPrimary:
                                                    Colors.black, //押したときの色
                                                shape: const StadiumBorder(),
                                                side: BorderSide(
                                                  color: Colors.black, //枠線の色
                                                  width: 2, //枠線の太さ
                                                ),
                                              ),
                                              onPressed: () {
                                                _collect = true;
                                                _onClutch = true;
                                              }),
                                        ),
                                      )
                                    : Container(
                                        margin: EdgeInsets.only(
                                            top: _shoreHeight +
                                                50 +
                                                (5 * _commonAnime.value),
                                            left: 10),
                                        child:
                                            //ルアー
                                            GestureDetector(
                                                onTap: () async {
                                                  if (_depth <= 0.0) {
                                                    setState(() {
                                                      _selectTacleIcon = 'lure';
                                                      _showTacleChangeDialog =
                                                          true;
                                                      soundManagerPool
                                                          .playSound(
                                                              'se/boxopen.mp3');
                                                    });
                                                  }
                                                },
                                                child: tackleIcon(
                                                  tackleIconSize: 40.0,
                                                  lure: uselureData,
                                                  flgSelect: false,
                                                  opacity: (_depth > 0.0
                                                      ? 0.7
                                                      : 1.0),
                                                )),
                                      ),
                                (settings.flgControlRight)
                                    ?
                                    //回収ボタン ？？？デザインは仮だから
                                    AnimatedOpacity(
                                        opacity: _depth > 0.0 &&
                                                !_flgBait &&
                                                !_flgHit
                                            ? 1.0
                                            : 0.0,
                                        duration: Duration(milliseconds: 200),
                                        child: Container(
                                          margin: EdgeInsets.only(
                                              top: _shoreHeight + 50,
                                              right: 10),
                                          child: ElevatedButton(
                                              child: const Text('回収'),
                                              style: ElevatedButton.styleFrom(
                                                primary: Colors.amber, //背景色
                                                onPrimary:
                                                    Colors.black, //押したときの色
                                                shape: const StadiumBorder(),
                                                side: BorderSide(
                                                  color: Colors.black, //枠線の色
                                                  width: 2, //枠線の太さ
                                                ),
                                              ),
                                              onPressed: () {
                                                _collect = true;
                                                _onClutch = true;
                                              }),
                                        ),
                                      )
                                    : Container(
                                        margin: EdgeInsets.only(
                                            top: _shoreHeight +
                                                50 +
                                                (5 * _commonAnime.value),
                                            right: 10),
                                        child:
                                            //ルアー
                                            GestureDetector(
                                                onTap: () async {
                                                  if (_depth <= 0.0) {
                                                    setState(() {
                                                      _selectTacleIcon = 'lure';
                                                      _showTacleChangeDialog =
                                                          true;
                                                      soundManagerPool
                                                          .playSound(
                                                              'se/boxopen.mp3');
                                                    });
                                                  }
                                                },
                                                child: tackleIcon(
                                                  tackleIconSize: 40.0,
                                                  lure: uselureData,
                                                  flgSelect: false,
                                                  opacity: (_depth > 0.0
                                                      ? 0.7
                                                      : 1.0),
                                                )),
                                      ),
                              ],
                            ),
                            Row(
                                mainAxisAlignment: (settings.flgControlRight)
                                    ? MainAxisAlignment.start
                                    : MainAxisAlignment.end,
                                children: [
                                  Container(
                                    margin: EdgeInsets.only(left: 8),
                                    child: new FishCardList(
                                      fishsTable: _fishCardItem,
                                      fishesResult: fishesResult,
                                      hitFishId: (_flgHit || _flgBait)
                                          ? _hitFish.id
                                          : -1,
                                      pointerColor: _pointerColor,
                                      borderWidth: _animationRadius.value,
                                      flgRight: settings.flgControlRight,
                                    ),
                                  ),
                                ])
                          ],
                        ),
                        AnimatedPadding(
                          //curve: Curves.easeOutExpo,
                          padding: EdgeInsets.only(
                            right: _showTacleChangeDialog ? 0.0 : size.width,
                            top: _shoreHeight,
                          ),
                          duration: Duration(milliseconds: 200),
                          child: GestureDetector(
                            onTap: () {
                              //欄外のタップイベントを起こさないための空イベント
                            },
                            onPanStart: (DragStartDetails details) {
                              //欄外のタップイベントを起こさないための空イベント
                            },
                            child: Container(
                              decoration: BoxDecoration(
                                  border: Border.all(
                                      color: Colors.black.withOpacity(0.3),
                                      width: 1)),
                              //title: Text("タックル変更"),
                              child: Visibility(
                                  visible: _showTacleChangeDialog,
                                  child: Container(
                                    color: Colors.black.withOpacity(0.3),
                                    child: Column(children: <Widget>[
                                      // Row(
                                      //     mainAxisAlignment:
                                      //         MainAxisAlignment.center,
                                      //     children: [
                                      //       Text(
                                      //         "使用中のタックル",
                                      //         textAlign: TextAlign.center,
                                      //         style: TextStyle(
                                      //             color: Colors.white,
                                      //             fontWeight: FontWeight.bold,
                                      //             fontSize: 20,
                                      //             fontFamily: 'OpenSans',
                                      //             decoration:
                                      //                 TextDecoration.none,
                                      //             shadows: <Shadow>[
                                      //               Shadow(
                                      //                   offset:
                                      //                       Offset(1.0, 3.0),
                                      //                   blurRadius: 2.0,
                                      //                   color: Colors.black
                                      //                       .withOpacity(0.8))
                                      //             ]),
                                      //       )
                                      //     ]),
                                      FittedBox(
                                        //margin: EdgeInsets.only(top: 4, bottom: 4),
                                        child: Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.center,
                                          children: [
                                            //タイラバ
                                            GestureDetector(
                                              onTap: () {
                                                setState(() {
                                                  _useLureId =
                                                      enumLureDiv.tairaba;
                                                  //使用中のルアーを変更
                                                  uselureData = lures
                                                      .getLureData(_useLureId);
                                                });
                                              },
                                              child: Container(
                                                  padding: EdgeInsets.all(10),
                                                  child: tackleIcon(
                                                    tackleIconSize: 60.0,
                                                    lure: lures.getLureData(
                                                        enumLureDiv.tairaba),
                                                    flgSelect: _useLureId ==
                                                            enumLureDiv.tairaba
                                                        ? true
                                                        : false,
                                                    opacity: (_depth > 0.0
                                                        ? 0.7
                                                        : 1.0),
                                                  )),
                                            ),
                                            //メタルジグ
                                            GestureDetector(
                                              onTap: () {
                                                setState(() {
                                                  _useLureId = enumLureDiv.jig;
                                                  //使用中のルアーを変更
                                                  uselureData = lures
                                                      .getLureData(_useLureId);
                                                });
                                              },
                                              child: Container(
                                                  padding: EdgeInsets.all(10),
                                                  child: tackleIcon(
                                                    tackleIconSize: 60.0,
                                                    lure: lures.getLureData(
                                                        enumLureDiv.jig),
                                                    flgSelect: _useLureId ==
                                                            enumLureDiv.jig
                                                        ? true
                                                        : false,
                                                    opacity: (_depth > 0.0
                                                        ? 0.7
                                                        : 1.0),
                                                  )),
                                            ),

                                            //スロージグ
                                            GestureDetector(
                                              onTap: () {
                                                setState(() {
                                                  _useLureId =
                                                      enumLureDiv.slowjig;
                                                  //使用中のルアーを変更
                                                  uselureData = lures
                                                      .getLureData(_useLureId);
                                                });
                                              },
                                              child: Container(
                                                  padding: EdgeInsets.all(10),
                                                  child: tackleIcon(
                                                    tackleIconSize: 60.0,
                                                    lure: lures.getLureData(
                                                        enumLureDiv.slowjig),
                                                    flgSelect: _useLureId ==
                                                            enumLureDiv.slowjig
                                                        ? true
                                                        : false,
                                                    opacity: (_depth > 0.0
                                                        ? 0.7
                                                        : 1.0),
                                                  )),
                                            ),
                                          ],
                                        ),
                                      ),
                                      Container(
                                        margin: EdgeInsets.only(top: 0),
                                        child: Text(
                                          uselureData.name +
                                              " Lv." +
                                              lures
                                                  .getLureData(_useLureId)
                                                  .lv
                                                  .toString(),
                                          style: TextStyle(
                                              color: uselureData
                                                  .getLureColor(_useLureId),
                                              fontSize: 16,
                                              fontWeight: FontWeight.bold),
                                        ),
                                      ),
                                      Container(
                                        width: size.width,
                                        margin:
                                            EdgeInsets.only(top: 10, left: 10),
                                        child: Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.center,
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            //ステータス
                                            new RadarChart(
                                              key: UniqueKey(),
                                              items: getLureRadarChartItem(),
                                              borderColor: Colors.white,
                                              radarColors: [Colors.orange],
                                              fontColor: Colors.white,
                                            ),
                                            Container(
                                              margin: EdgeInsets.only(
                                                  left: 10, right: 10),
                                              // child: Column(
                                              //   // crossAxisAlignment:
                                              //   //     CrossAxisAlignment.start,
                                              //   children: [
                                              //重さ
                                              //rbLureWeight(uselureData),
                                              child: FittedBox(
                                                child: Column(
                                                    mainAxisAlignment:
                                                        MainAxisAlignment.start,
                                                    children: <Widget>[
                                                      Center(
                                                        child: Text(
                                                          '重さ：' +
                                                              uselureData
                                                                  .getMyWeight()
                                                                  .toString() +
                                                              "g",
                                                          style: TextStyle(
                                                              fontWeight:
                                                                  FontWeight
                                                                      .bold,
                                                              color:
                                                                  Colors.white),
                                                        ),
                                                      ),
                                                      Container(
                                                        decoration: BoxDecoration(
                                                            border: Border.all(
                                                                color: Colors
                                                                    .black),
                                                            color:
                                                                Colors.white),
                                                        height: uselureData
                                                                .weightList
                                                                .list
                                                                .length *
                                                            24,
                                                        width: 100,
                                                        child: ListView.builder(
                                                          padding:
                                                              EdgeInsets.only(
                                                                  top: 0,
                                                                  bottom: 0),
                                                          itemBuilder:
                                                              (BuildContext
                                                                      context,
                                                                  int index) {
                                                            //return Text(uselureData.weightList.list[index].weight.toString());
                                                            return GestureDetector(
                                                              onTap: () {
                                                                setState(() {
                                                                  if (uselureData
                                                                      .weightList
                                                                      .list[
                                                                          index]
                                                                      .enabled) {
                                                                    setState(
                                                                        () {
                                                                      uselureData
                                                                              .useWeightId =
                                                                          index;
                                                                    });
                                                                  }
                                                                  ;
                                                                });
                                                              },
                                                              child: Container(
                                                                  padding:
                                                                      EdgeInsets
                                                                          .all(
                                                                              3),
                                                                  decoration:
                                                                      BoxDecoration(
                                                                    // border: Border.all(
                                                                    //     color: Colors
                                                                    //         .black),
                                                                    //色 使用中：黄／使用可：白／使用不可：灰色
                                                                    color: (uselureData.useWeightId ==
                                                                            index
                                                                        ? Colors
                                                                            .yellow
                                                                        : (!uselureData.weightList.list[index].enabled
                                                                            ? Colors.grey
                                                                            : Colors.white)),
                                                                  ),
                                                                  child: Text(
                                                                    uselureData
                                                                            .weightList
                                                                            .list[index]
                                                                            .weight
                                                                            .toString() +
                                                                        "g",
                                                                    style: TextStyle(
                                                                        fontSize:
                                                                            12),
                                                                  )),
                                                            );

                                                            //     return Row(
                                                            //         children: <
                                                            //             Widget>[
                                                            //           Radio(
                                                            //             materialTapTargetSize:
                                                            //                 MaterialTapTargetSize
                                                            //                     .shrinkWrap,
                                                            //             activeColor:
                                                            //                 Colors
                                                            //                     .blueAccent,
                                                            //             value:
                                                            //                 index,
                                                            //             groupValue:
                                                            //                 uselureData
                                                            //                     .useWeightId,
                                                            //             onChanged: (int?
                                                            //                 value) {
                                                            //               setState(
                                                            //                   () {
                                                            //                 uselureData.useWeightId =
                                                            //                     value!;
                                                            //               });
                                                            //             },
                                                            //           ),
                                                            //           Text(
                                                            //             uselureData
                                                            //                     .weightList
                                                            //                     .list[index]
                                                            //                     .weight
                                                            //                     .toString() +
                                                            //                 "g",
                                                            //             style: TextStyle(
                                                            //                 fontSize:
                                                            //                     12),
                                                            //           ),
                                                            //         ],
                                                            //     );
                                                          },
                                                          itemCount: uselureData
                                                              .weightList
                                                              .list
                                                              .length,
                                                        ),
                                                      )
                                                    ]),
                                              ),

                                              // Row(
                                              //   children: [
                                              //     Text(
                                              //       '重さ：',
                                              //       style: TextStyle(
                                              //           color:
                                              //               Colors.white),
                                              //     ),
                                              //     Text(
                                              //       uselureData
                                              //               .getMyWeight()
                                              //               .toString() +
                                              //           'g',
                                              //       style: TextStyle(
                                              //           color:
                                              //               Colors.white),
                                              //     )
                                              //   ],
                                              // ),
                                              //説明テキスト
                                              // Expanded(
                                              //     child:
                                              // Container(
                                              //     height: 100,
                                              //     width: size.width / 2,
                                              //     padding: EdgeInsets.only(
                                              //         left: 10, right: 10),
                                              //     decoration: BoxDecoration(
                                              //         border: Border.all(
                                              //             color:
                                              //                 Colors.black,
                                              //             width: 3),
                                              //         borderRadius:
                                              //             BorderRadius.all(
                                              //                 Radius
                                              //                     .circular(
                                              //                         7.0)),
                                              //         color: clsColor
                                              //             .getColorFromHex(
                                              //                 '#DFDFDF')),
                                              //     child: Text(
                                              //       lures
                                              //           .getLureData(
                                              //               haveTackle
                                              //                   .getUseLure()
                                              //                   .lureId)
                                              //           .text,
                                              //       style: TextStyle(
                                              //           color:
                                              //               Colors.black),
                                              //     )),
                                              //),
                                              //   ],
                                              // ),
                                            ),
                                          ],
                                        ),
                                      ),
                                      //閉じるボタン
                                      Container(
                                        margin: EdgeInsets.only(top: 10),
                                        child: ElevatedButton.icon(
                                          icon: const Icon(
                                            Icons.close,
                                            color: Colors.white,
                                          ),
                                          label: const Text('閉じる'),
                                          style: ElevatedButton.styleFrom(
                                            primary:
                                                Colors.grey.withOpacity(0.5),
                                            onPrimary: Colors.white,
                                          ),
                                          onPressed: () {
                                            soundManagerPool
                                                .playSound('se/boxclose.mp3');
                                            setState(() {
                                              _showTacleChangeDialog = false;
                                            });
                                          },
                                        ),
                                      ),
                                    ]),
                                  )),
                            ),
                          ),
                        ),
                      ]),
                    ])))));
  }

  //タップ時のエフェクトのリスト
  List<TapPointer> tapPointerList = <TapPointer>[];
  // アニメーションの終了を Future<void>.delayed で待ち、終わった時に removeAt(0) でリストから取り出している
  // 取り出すと そのタイミングで dispose が呼ばれる。
  Future<void> generateTapPointer(DragStartDetails details) async {
    const duration = const Duration(milliseconds: 1000);
    final tapPointer = TapPointer(
      key: UniqueKey(), // 必ずキーを与えること。これによりそれぞれが独立した描画になります。
      offset: offset,
      duration: duration,
    );
    setState(() {
      tapPointerList.add(tapPointer);
    });
    await Future<void>.delayed(duration);
    setState(() {
      tapPointerList.removeAt(0);
    });
  }

  //魚アイコンのリスト
  List<FishPointer> fishPointerList = <FishPointer>[];
  // アニメーションの終了を Future<void>.delayed で待ち、終わった時に removeAt(0) でリストから取り出している
  // 取り出すと そのタイミングで dispose が呼ばれる。
  Future<void> generateFishPointer(offsetY, fishPointerSize) async {
    const duration = const Duration(milliseconds: 20000);
    var size = MediaQuery.of(context).size;
    var rnd = (new math.Random()).nextDouble();
    var offsetX =
        (size.width / 4) + (size.width / 2) * (rnd * rnd); //真ん中に集約するように累乗する
    // if (!settings.flgControlRight) {
    //   offsetX += size.width / 4;
    // } else {
    //   offsetX -= size.width / 4;
    // }
    offsetX = (offsetX < 0) ? 0 : offsetX;
    offsetX = (offsetX > size.width) ? size.width : offsetX;

    final fishPointer = FishPointer(
      key: UniqueKey(), // 必ずキーを与えること。これによりそれぞれが独立した描画になります。
      dispSizeX: size.width, //画面サイズX
      offsetY: offsetY,
      offsetX: offsetX,
      duration: duration,
      fishPointerSize: fishPointerSize,
      takclePositionRight: settings.flgControlRight,
      painterKey: GlobalKey(),
      randMove: (new math.Random()).nextDouble(),
    );
    setState(() {
      fishPointerList.add(fishPointer);
    });
    //_cache.play('se/kk_sonar_low.mp3');
    //play('assets/se/kk_sonar_low.mp3');
    if (!_flgHit && !_flgBait)
      soundManagerPool.playSound('se/kk_sonar_low.mp3');
    await Future<void>.delayed(duration);
    if (!mounted) {
      return;
    }
    setState(() {
      fishPointerList.removeAt(0);
    });
  }

  //クラッチ状態変更
  void chengeClutch(bool flg) {
    if (flg == _onClutch) {
      //状態変更無し時は無処理
      return;
    }
    if (_collect) {
      return;
    }
    if (flg) {
      //クラッチOFF→ONに変更
      _clutchBackColor = Colors.lightBlue;
      if (_depth <= 0.0) {
        //着水音
        soundManagerPool.playSound('se/waterlanding.mp3');
      } else {
        soundManagerPool.playSound('se/clutch.mp3');
      }
    } else {
      _clutchBackColor = Colors.red;
      soundManagerPool.playSound('se/clutch.mp3');
    }
    _onClutch = flg;
  }

  bool ligntSpotAnimation(bool initflg, int durationMsec) {
    if (initflg || !_animationController.isAnimating) {
      //アニメーションの定義
      _animationController = AnimationController(
          duration: Duration(milliseconds: durationMsec), vsync: this);
      _animationRadius = Tween(begin: 0.0, end: POINTER_BACK_SIZE)
          .animate(_animationController)
        ..addListener(() {
          setState(() {});
        });
      _animationController.repeat(reverse: false);
      _ligntSpotAnimationChangeing = false;
      return true;
    } else {
      if (!_ligntSpotAnimationChangeing) {
        _animationController.forward();
        _ligntSpotAnimationChangeing = true;
      }
      return false;
    }
  }

  //画面中央のメッセージ
  startCenterInfo() {
    //HIT時のアニメーションの定義
    _centerTextAnimationController = AnimationController(
        duration: Duration(milliseconds: 2000), vsync: this);
    _centerTextLeft =
        Tween(begin: 0.0, end: MediaQuery.of(context).size.width / 2).animate(
            _centerTextAnimationController
                .drive(CurveTween(curve: Curves.slowMiddle)))
          ..addListener(() {
            setState(() {});
          });
    _centerTextAnimationController.forward();
  }

  //ジャーク表示
  startJerk(String actionText) {
    //ジャーク時のアニメーションの定義
    _jerkTextAnimationController =
        AnimationController(duration: Duration(milliseconds: 800), vsync: this);
    _jerkTextLocation =
        Tween(begin: 0.0, end: 1.0).animate(_jerkTextAnimationController)
          ..addListener(() {
            setState(() {});
          });
    _jerkTextAnimationController.forward();
    _actionText = actionText;
  }

  //ルアーの能力チャート描画
  List<RadarChartItemModel> getLureRadarChartItem() {
    List<RadarChartItemModel> ret = [];
    ret.add(
        new RadarChartItemModel(itemName: '巻き', value: uselureData.reeling));
    ret.add(new RadarChartItemModel(itemName: 'ﾌｫｰﾙ', value: uselureData.fall));
    ret.add(new RadarChartItemModel(itemName: 'ｼｬｸﾘ', value: uselureData.jerk));
    return ret;
  }

  //0.0～1.0のアニメーション値を倍々にする
  double animeHosei(double val, int multiple) {
    //return val / (1.0 / multiple);
    var v = val % (1.0 / multiple);
    //return (1 / multiple) * math.sin(4 * v);
    return v;
  }
}

//タックルサムネの表示
Widget tackleIcon({
  required double tackleIconSize,
  required LureModel lure,
  required bool flgSelect,
  // required String imagePath,
  // String subText = '',
  // String lvText = '',
  // int hp = 0,
  // int maxHp = 0,
  double opacity = 1.0,
}) {
  //final value = hp / maxHp;
  return SizedBox(
    width: tackleIconSize,
    height: tackleIconSize,
    child: Container(
      padding: EdgeInsets.all(0),
      decoration: BoxDecoration(
        border: Border.all(
            color: flgSelect ? Colors.yellow : Colors.black,
            width: flgSelect ? 3 : 1),
        image: DecorationImage(
            image: AssetImage('assets/images/' + lure.image),
            colorFilter: new ColorFilter.mode(
                Colors.black.withOpacity(opacity), BlendMode.dstATop),
            fit: BoxFit.contain),
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            lure.getWeight(lure.useWeightId).toString() + 'g',
            style: TextStyle(fontSize: 12),
          ),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              Text(
                'Lv ' + lure.lv.toString(),
                style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold),
              ),
            ],
          ),
          //HPバーの表示 ボツ
          // Visibility(
          //   visible: (maxHp > 0),
          //   child: Container(
          //     margin: EdgeInsets.all(3),
          //     child: CustomPaint(
          //       painter: new SliderPainter(
          //         height: 4,
          //         activeColor: clsColor.getRaitoColor(hp / maxHp),
          //         inactiveColor: Colors.white,
          //         value: hp.toDouble(),
          //         maxValue: maxHp.toDouble(),
          //         backRadius: 0,
          //         maxBackRadius: 0,
          //         flgShaKe: false,
          //         flgDispValue: false,
          //         flgDispMaxValue: false,
          //       ),
          //       child: Container(),
          //     ),
          //   ),
          // ),
        ],
      ),
    ),
  );
}

class ShakeCurve extends Curve {
  @override
  double transform(double t) {
    return 64 * math.sin(2 * math.pi * t);
  }
}

//累乗の計算（DartのMath.powだと実数の戻り値ができないため自作）
class MathPow {
  static double _getPow(int x, double d) {
    double ret = d;
    for (var i = 1; i < x; i++) {
      ret = ret * d;
    }
    return ret;
  }
}
